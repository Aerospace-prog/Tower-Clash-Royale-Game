<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="./img/CRlogo.png">
    <title>Simple Tower Clash - Log Fixed</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- CSS (No Changes) --- */
        :root {
            --primary-bg: #1e2a3a; --secondary-bg: #2c3e50; --tertiary-bg: #3b5970;
            --accent-blue: #3498db; --accent-red: #e74c3c; --accent-green: #2ecc71;
            --accent-purple: #9b59b6; --accent-yellow: #f1c40f; --accent-gray: #7f8c8d;
            --text-light: #ecf0f1; --text-dark: #2c3e50; --border-color: #1a2531;
            --card-bg: #4a6883; --elixir-color: var(--accent-purple);
            --knight-color: '#bdc3c7'; --skeletons-color: '#ecf0f1'; --bats-color: '#512E5F';
            --hog-color: '#f39c12'; /* Hog Rider */
            --log-color: '#8B4513'; /* The Log */
            --cannon-color: '#95a5a6'; /* Cannon */


            --bg-gradient: linear-gradient(to bottom, #23344a, #1a2a3a);
            --container-gradient: linear-gradient(to bottom, #3a4c60, #2c3e50);
            --button-blue-gradient: linear-gradient(to bottom, #5dade2, #3498db);
            --button-green-gradient: linear-gradient(to bottom, #58d68d, #2ecc71);
            --button-gray-gradient: linear-gradient(to bottom, #95a5a6, #7f8c8d); /* Cannon uses this */
            --button-purple-gradient: linear-gradient(to bottom, #af7ac5, #9b59b6);
            --button-red-gradient: linear-gradient(to bottom, #ec7063, #e74c3c);
            --button-white-gradient: linear-gradient(to bottom, #f8f9f9, #e5e7e9);
            --button-silver-gradient: linear-gradient(to bottom, #e5e7e9, #bdc3c7); /* Knight */
            --button-darkpurple-gradient: linear-gradient(to bottom, #7d3c98, #512e5f); /* Bats */
            --button-orange-gradient: linear-gradient(to bottom, #f5b041, #f39c12); /* Fireball / Hog */
            --button-brown-gradient: linear-gradient(to bottom, #a05a2c, #8B4513); /* Log */
            --canvas-gradient: linear-gradient(to bottom, #bdc3c7, #95a5a6);
        }
        body {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            min-height: 100vh; background-color: var(--primary-bg); background-image: var(--bg-gradient);
            font-family: 'Press Start 2P', cursive; color: var(--text-light); margin: 0; padding-top: 20px; overflow-x: hidden;
        }
        /* Screen Containers */
        .screen { display: none; width: 100%; max-width: 900px; padding: 20px; border: 5px solid var(--border-color); background-color: var(--secondary-bg); border-radius: 15px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4); margin: 15px; box-sizing: border-box; }
        .screen.active { display: block; }
        /* General Styles */
        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-red); text-shadow: 2px 2px #000; }
        h1 { font-size: 1.8em; margin-top: 0; }
        h2 { font-size: 1.4em; color: var(--accent-blue); }
        button { /* Base button style */
            font-family: 'Press Start 2P', cursive; padding: 10px 18px; border: none; border-radius: 8px;
            cursor: pointer; background-color: var(--accent-blue); color: white; text-shadow: 1px 1px #000;
            transition: all 0.2s ease; box-shadow: 0 4px #1f618d; font-size: 0.9em;
        }
        button:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-1px); box-shadow: 0 5px #1f618d; }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 2px #1f618d; }
        button:disabled { background-color: var(--accent-gray); cursor: not-allowed; box-shadow: 0 4px #566573; opacity: 0.7; }
        #resetButton { background-image: var(--button-red-gradient); border: 2px solid rgba(0,0,0,0.5); border-top-color: rgba(255,255,255,0.2); border-left-color: rgba(255,255,255,0.2); box-shadow: 0 5px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #resetButton:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 7px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #resetButton:active:not(:disabled) { transform: translateY(2px); filter: brightness(0.9); box-shadow: 0 2px 0px rgba(0,0,0,0.3), inset 0 2px 3px rgba(0,0,0,0.3); }

        /* Deck Builder Screen */
        #deckBuilderScreen h2 { margin-top: 25px; }
        .deck-areas { display: flex; flex-direction: column; gap: 20px; }
        #cardLibrary, #selectedDeck { display: flex; flex-wrap: wrap; gap: 10px; padding: 15px; background-color: var(--tertiary-bg); border-radius: 10px; min-height: 100px; justify-content: center; }
        #selectedDeck { border: 3px dashed var(--accent-green); min-height: 95px; max-width: 600px; margin: 0 auto; } /* Width for 8 cards */
        .deck-slot-placeholder { width: 70px; height: 90px; background-color: rgba(0,0,0,0.2); border: 2px dashed var(--border-color); border-radius: 5px; box-sizing: border-box; }
        .card { /* Style for cards in library/deck */
            width: 70px; height: 90px; background-color: var(--card-bg); border: 2px solid var(--border-color); border-radius: 5px;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 5px; box-sizing: border-box;
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; position: relative; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .card:hover { transform: scale(1.05); border-color: var(--accent-yellow); box-shadow: 0 4px 10px rgba(0,0,0,0.4); }
        .card.disabled-card { opacity: 0.5; cursor: not-allowed; background-color: #555; }
        .card.disabled-card:hover { transform: none; border-color: var(--border-color); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .card-cost { position: absolute; top: 2px; left: 2px; background-color: var(--elixir-color); color: white; font-size: 0.7em; padding: 2px 4px; border-radius: 3px; font-weight: bold; border: 1px solid rgba(255,255,255,0.5); z-index: 1; }
        .card-name {
            font-size: 0.6em; text-align: center; margin-top: auto;
            color: var(--accent-yellow); text-shadow: 1px 1px 1px #000;
            word-break: break-word; line-height: 1.1; width: 100%; padding-bottom: 2px;
        }
        .card-icon {
            width: 45px; height: 55px; margin-top: 18px; margin-bottom: 2px;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .card-icon img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 3px; }
         .card-icon .fallback-text { font-size: 0.8em; color: var(--text-light); text-align: center; }

        #startBattleButton { display: block; margin: 25px auto 10px auto; padding: 12px 30px; font-size: 1.1em; background-image: var(--button-green-gradient); border: 2px solid rgba(0,0,0,0.5); border-top-color: rgba(255,255,255,0.2); border-left-color: rgba(255,255,255,0.2); box-shadow: 0 5px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #startBattleButton:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 7px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }

        /* Battle Screen */
        .game-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; font-size: 0.9em; flex-wrap: wrap; gap: 10px; background-color: rgba(0,0,0,0.2); padding: 10px 15px; border-radius: 10px; border: 2px solid rgba(0,0,0,0.3); }
        #player-stats, #enemy-stats, #game-timer-container { text-align: center; padding: 8px 12px; background: linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(0,0,0,0.05)); border-radius: 8px; flex-grow: 1; flex-basis: 150px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }
        #player-stats { border-left: 5px solid var(--accent-blue); }
        #enemy-stats { border-right: 5px solid var(--accent-red); }
        #game-timer-container { border-bottom: 5px solid var(--accent-yellow); flex-basis: 100px; padding: 10px 5px; }
        #player-tower-hp, #enemy-tower-hp, #gameTimerDisplay { display: block; margin-top: 8px; font-weight: bold; text-shadow: 1px 1px 1px #000; }
        #player-tower-hp, #enemy-tower-hp { font-size: 1.0em; }
        #gameTimerDisplay { color: var(--accent-yellow); font-size: 1.4em; }
        /* Elixir Bar Styles */
        #player-elixir-display { background-color: transparent; padding: 0; display: block; margin-top: 10px; }
        .elixir-text { display: block; font-size: 1.0em; margin-bottom: 4px; color: var(--text-light); text-shadow: 1px 1px 1px #000; }
        .elixir-bar-container { width: 100%; max-width: 120px; height: 12px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden; margin: 0 auto; }
        .elixir-bar-fill { height: 100%; width: 0%; background-color: var(--elixir-color); border-radius: 3px; transition: width 0.2s ease-out; box-shadow: inset 0 0 3px rgba(255,255,255,0.3); }
        #gameCanvas { display: block; background-color: #aaa; background-image: var(--canvas-gradient); border: 4px solid var(--text-dark); margin: 0 auto 20px auto; max-width: 100%; height: auto; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); cursor: default; }
        #targetingIndicator { position: absolute; border: 3px dashed var(--accent-red); border-radius: 50%; background-color: rgba(231, 76, 60, 0.2); pointer-events: none; display: none; box-sizing: border-box; z-index: 5; }
        /* Added for placement validation */
        #placementIndicator { position: absolute; border: 3px solid green; border-radius: 5px; background-color: rgba(46, 204, 113, 0.2); pointer-events: none; display: none; box-sizing: border-box; z-index: 5; }
        #placementIndicator.invalid { border-color: red; background-color: rgba(231, 76, 60, 0.2); }

        #battleControls { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin-top: 15px; padding: 10px; background-color: var(--tertiary-bg); border-radius: 8px; min-height: 95px; border: 2px solid rgba(0,0,0,0.3); }
        button.deploy-button {
             width: 65px; height: 85px; background-color: var(--card-bg); border: 2px solid var(--border-color); border-radius: 5px;
             display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 5px; box-sizing: border-box;
             cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; position: relative; overflow: hidden;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 0.6em; text-shadow: none;
             color: var(--text-light); /* Default color for name, overridden by .card-name */
        }
        button.deploy-button:hover:not(:disabled) { transform: scale(1.05); border-color: var(--accent-yellow); box-shadow: 0 4px 10px rgba(0,0,0,0.4); filter: brightness(1.1); }
        button.deploy-button:active:not(:disabled) { transform: scale(1.02); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        button.deploy-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #555; transform: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3); border-color: var(--border-color); filter: grayscale(50%);}
        .deploy-button .card-cost {}
        .deploy-button .card-icon { width: 45px; height: 55px; margin-top: 18px; margin-bottom: 2px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .deploy-button .card-icon img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 3px; }
        .deploy-button .card-icon .fallback-text { font-size: 0.8em; color: var(--text-light); text-align: center; }
        .deploy-button .card-name { /* Inherits .card-name style */ margin-top: auto; }
        #messageBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(to bottom, rgba(44, 62, 80, 0.95), rgba(26, 42, 58, 0.95)); color: #fff; padding: 40px 50px; border-radius: 15px; font-size: 2.2em; text-align: center; display: none; z-index: 1000; border: 5px solid var(--accent-red); white-space: pre-line; box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 0 10px rgba(0,0,0,0.4); text-shadow: 2px 2px 3px #000; }

    </style>
</head>
<body>

    <div id="deckBuilderScreen" class="screen active">
        <h1>Build Your Deck</h1>
        <div class="deck-areas">
            <div>
                <h2>Selected Deck (Click to Remove) - Select 8</h2>
                <div id="selectedDeck"></div>
            </div>
            <div>
                <h2>Card Library (Click to Add)</h2>
                <div id="cardLibrary"></div>
            </div>
        </div>
        <button id="startBattleButton" disabled>Start Battle (Select 8 Cards)</button>
    </div>

    <div id="battleScreen" class="screen">
        <h1>Battle!</h1>
        <div class="game-info">
            <div id="player-stats"> Player <span id="player-tower-hp">King HP: 1000</span>
                 <span id="player-elixir-display">
                     <span class="elixir-text">Elixir: 3 / 10</span>
                     <div class="elixir-bar-container"> <div class="elixir-bar-fill"></div> </div>
                 </span>
            </div>
            <div id="game-timer-container"> Time Left <span id="gameTimerDisplay">3:00</span> </div>
            <div id="enemy-stats"> Enemy <span id="enemy-tower-hp">King HP: 1000</span> </div>
        </div>
        <div style="position: relative; max-width: 800px; margin: 0 auto 15px auto;">
             <canvas id="gameCanvas" width="800" height="250"></canvas>
             <div id="targetingIndicator"></div>
             <div id="placementIndicator"></div> </div>
        <div id="battleControls"></div>
        <button id="resetButton">End Battle & Build Deck</button>
    </div>

    <div id="messageBox">You Win!</div>


    <script>
        // --- DOM Elements ---
        const deckBuilderScreen = document.getElementById('deckBuilderScreen');
        const battleScreen = document.getElementById('battleScreen');
        const cardLibraryContainer = document.getElementById('cardLibrary');
        const selectedDeckContainer = document.getElementById('selectedDeck');
        const startBattleButton = document.getElementById('startBattleButton');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const playerElixirDisplaySpan = document.querySelector('#player-elixir-display .elixir-text');
        const playerElixirBarFill = document.querySelector('#player-elixir-display .elixir-bar-fill');
        const playerTowerHpDisplay = document.getElementById('player-tower-hp');
        const enemyTowerHpDisplay = document.getElementById('enemy-tower-hp');
        const battleControlsContainer = document.getElementById('battleControls');
        const messageBox = document.getElementById('messageBox');
        const resetButton = document.getElementById('resetButton');
        const gameTimerDisplay = document.getElementById('gameTimerDisplay');
        const targetingIndicator = document.getElementById('targetingIndicator');
        const placementIndicator = document.getElementById('placementIndicator'); // Added

        // --- Game Configuration ---
        const KING_TOWER_HP = 1000; const PRINCESS_TOWER_HP = 600; const TOWER_RANGE = 150;
        const KING_TOWER_DAMAGE = 10; const PRINCESS_TOWER_DAMAGE = 12; const TOWER_ATTACK_SPEED = 1000;
        const KING_TOWER_WIDTH = 60; const KING_TOWER_HEIGHT = 100; const PRINCESS_TOWER_WIDTH = 45; const PRINCESS_TOWER_HEIGHT = 75;
        const MAX_ELIXIR = 10; const ELIXIR_REGEN_RATE = 1; const ELIXIR_REGEN_INTERVAL = 1000; // 1 elixir per second
        const BATTLE_DURATION_SECONDS = 180; const TIEBREAKER_HP_DRAIN_RATE = 15; const TIEBREAKER_DRAIN_INTERVAL = 500;
        const DECK_SIZE = 8;
        const PLACEMENT_TILE_SIZE = 30; // For building placement checks
        const PLAYER_SIDE_X_LIMIT = 400; // Midpoint of 800 width canvas

        // --- Card Library with imageUrl ---
        const PLACEHOLDER_URL_BASE = "https://placehold.co/60x80/4a6883/ecf0f1?text=";
        const FULL_CARD_LIBRARY = [
            // --- Existing Units ---
            { id: 'melee', name: 'Mini Pekka', type: 'unit', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000018.webp`, stats: { hp: 100, damage: 15, speed: 1.5, range: 25, attackSpeed: 800, size: 20, color: '#3498db', shape: 'square', maxHp: 100, targets: ['ground'] } }, // Added targets
            { id: 'ranged', name: 'Archer', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000001.webp`, stats: { hp: 60, damage: 10, speed: 1.2, range: 100, attackSpeed: 1000, size: 18, color: '#2ecc71', shape: 'circle', maxHp: 60, targets: ['air', 'ground'] } }, // Added targets
            { id: 'tank', name: 'Giant', type: 'unit', cost: 5, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000003.webp`, stats: { hp: 250, damage: 10, speed: 0.8, range: 25, attackSpeed: 1200, size: 25, color: '#7f8c8d', shape: 'square', maxHp: 250, targets: ['ground'], targetPreference: 'building' } }, // Added targets, preference
            { id: 'assassin', name: 'Bandit', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000046.webp`, stats: { hp: 80, damage: 35, speed: 2.0, range: 25, attackSpeed: 900, size: 18, color: '#8e44ad', shape: 'diamond', maxHp: 80, targets: ['ground'] } }, // Added targets
            { id: 'skeletons', name: 'Skeletons', type: 'unit', cost: 1, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000010.webp`, stats: { spawnCount: 3, unitStats: { hp: 15, damage: 5, speed: 1.8, range: 25, attackSpeed: 1000, size: 15, color: '#ecf0f1', shape: 'circle', maxHp: 15, targets: ['ground'] } } }, // Added targets
            { id: 'knight', name: 'Knight', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000000.webp`, stats: { hp: 120, damage: 18, speed: 1.5, range: 25, attackSpeed: 900, size: 20, color: '#bdc3c7', shape: 'square', maxHp: 120, targets: ['ground'] } }, // Added targets
            { id: 'bats', name: 'Bats', type: 'unit', cost: 2, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000049.webp`, stats: { spawnCount: 3, unitStats: { hp: 15, damage: 6, speed: 2.2, range: 25, attackSpeed: 900, size: 15, color: '#512E5F', shape: 'diamond', maxHp: 15, isAir: true, targets: ['air', 'ground'] } } }, // Added targets

            // --- Existing Spells ---
            { id: 'fireball', name: 'Fireball', type: 'spell', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/28000000.webp`, stats: { damage: 100, radius: 50, delay: 500, targets: ['air', 'ground'] } }, // Added targets flag

            // --- *** NEWLY IMPLEMENTED CARDS *** ---
            { id: 'log', name: 'The Log', type: 'spell', cost: 2, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/28000011.webp`, stats: { damage: 40, width: 40, speed: 4, travelDistance: 350, pushbackStrength: 5, pushbackDuration: 150, targets: ['ground'] } },
            { id: 'cannon', name: 'Cannon', type: 'building', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/27000000.webp`, stats: { hp: 150, damage: 25, range: 130, attackSpeed: 800, lifetime: 30000, size: 40, color: '#95a5a6', maxHp: 150, targets: ['ground'] } },
            { id: 'hogrider', name: 'Hog Rider', type: 'unit', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000021.webp`, stats: { hp: 200, damage: 40, speed: 2.0, range: 25, attackSpeed: 1000, size: 22, color: '#f39c12', shape: 'square', maxHp: 200, targetPreference: 'building', targets: ['ground'] } }, // Added targets

            // --- Unimplemented Cards ---
            { id: 'arrows', name: 'Arrows', type: 'spell', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ARR` },
            { id: 'zap_evo', name: 'Zap Evo', type: 'spell', cost: 2, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ZAP` },
            { id: 'mortar_evo', name: 'Mortar Evo', type: 'building', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}MOR` },
            { id: 'princess', name: 'Princess', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}PRI` },
            { id: 'pekka', name: 'P.E.K.K.A', type: 'unit', cost: 7, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}PEK` },
            { id: 'guards', name: 'Guards', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GUA` },
            { id: 'icespirit', name: 'Ice Spirit', type: 'unit', cost: 1, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ICE` },
            { id: 'goblingang', name: 'Goblin Gang', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GG` },
            { id: 'babydragon', name: 'Baby Dragon', type: 'unit', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}BD` },
            { id: 'megaknight', name: 'Mega Knight', type: 'unit', cost: 7, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}MK` },
            { id: 'poison', name: 'Poison', type: 'spell', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}POI` },
            { id: 'golem', name: 'Golem', type: 'unit', cost: 8, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GOL` },
        ];
        function getCardById(id) { return FULL_CARD_LIBRARY.find(card => card.id === id); }

        const ENEMY_COLORS = {
             melee: '#c0392b', ranged: '#f1c40f', tank: '#566573', assassin: '#d2b4de',
             skeletons: '#bdc3c7', knight: '#95a5a6', bats: '#9B59B6',
             hogrider: '#e67e22', // Enemy Hog color
             cannon: '#7f8c8d', // Enemy Cannon color
        }
        const AI_DEPLOY_INTERVAL = 3000; // AI thinks every 3 seconds
        const AI_STARTING_ELIXIR = 5;

        // --- Game State ---
        let selectedDeck = [];
        let playerElixir = 3;
        let playerUnits = [];
        let enemyUnits = [];
        let playerBuildings = []; // <-- Added for buildings
        let enemyBuildings = []; // <-- Added for buildings
        let projectiles = [];
        let logProjectiles = []; // <-- Added for The Log
        let playerTowers = [];
        let enemyTowers = [];
        let attackEffects = [];
        let elixirIntervalId = null;
        let aiIntervalId = null;
        let animationFrameId = null;
        let gameOver = false;
        let aiElixir = 5;
        let gameTimerIntervalId = null;
        let gameTimeRemaining = BATTLE_DURATION_SECONDS;
        let isTiebreakerActive = false;
        let tiebreakerIntervalId = null;
        let tiebreakerEffectCounter = 0;
        let isTargetingSpell = false;
        let currentSpellType = null;
        let isPlacingBuilding = false; // <-- Added for building placement
        let currentBuildingType = null; // <-- Added for building placement

        // --- Tower Initialization ---
        function createTowers(isPlayer) {
            const canvasWidth = canvas?.width || 800; const canvasHeight = canvas?.height || 250;
            const kingY = canvasHeight / 2; const princessYOffset = 60;
            const kingX = isPlayer ? 80 : canvasWidth - 80 - KING_TOWER_WIDTH;
            const princessXOffset = KING_TOWER_WIDTH / 2 + PRINCESS_TOWER_WIDTH / 2 + 15;
            const kingTower = { id: isPlayer ? 'player_king' : 'enemy_king', x: kingX, y: kingY, hp: KING_TOWER_HP, maxHp: KING_TOWER_HP, width: KING_TOWER_WIDTH, height: KING_TOWER_HEIGHT, range: TOWER_RANGE, damage: KING_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: true, color: isPlayer ? '#3498db' : '#e74c3c', targets: ['air', 'ground'] };
            const princessLeft = { id: isPlayer ? 'player_pleft' : 'enemy_pleft', x: kingX + (isPlayer ? princessXOffset : -princessXOffset), y: kingY - princessYOffset, hp: PRINCESS_TOWER_HP, maxHp: PRINCESS_TOWER_HP, width: PRINCESS_TOWER_WIDTH, height: PRINCESS_TOWER_HEIGHT, range: TOWER_RANGE, damage: PRINCESS_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: false, color: isPlayer ? '#5dade2' : '#ec7063', targets: ['air', 'ground'] };
            const princessRight = { id: isPlayer ? 'player_pright' : 'enemy_pright', x: kingX + (isPlayer ? princessXOffset : -princessXOffset), y: kingY + princessYOffset, hp: PRINCESS_TOWER_HP, maxHp: PRINCESS_TOWER_HP, width: PRINCESS_TOWER_WIDTH, height: PRINCESS_TOWER_HEIGHT, range: TOWER_RANGE, damage: PRINCESS_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: false, color: isPlayer ? '#5dade2' : '#ec7063', targets: ['air', 'ground'] };
            return [princessLeft, kingTower, princessRight];
        }

        // --- Utilities ---
        function distance(x1, y1, x2, y2) { return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); }
        function isGroundUnit(unit) { return !unit?.stats?.isAir; } // Helper to check if unit is ground

        // --- Drawing ---
        function drawTower(tower) { /* ... (no changes) ... */
             if (!ctx || !tower) return;
             if (tower.hp > 0) {
                 const heightModifier = tower.isKingTower ? 1 : 0.8; const widthModifier = tower.isKingTower ? 1 : 0.9;
                 const actualHeight = tower.height * heightModifier; const actualWidth = tower.width * widthModifier;
                 const healthBarY = tower.y - actualHeight / 2 - 15; const healthBarHeight = 10;
                 ctx.fillStyle = tower.color; ctx.fillRect(tower.x, tower.y - actualHeight / 2, actualWidth, actualHeight);
                 ctx.fillStyle = lightenColor(tower.color, 20);
                 if (tower.isKingTower) { ctx.fillRect(tower.x + actualWidth * 0.1, tower.y - actualHeight / 2, actualWidth * 0.8, 10); }
                  else { ctx.beginPath(); ctx.moveTo(tower.x, tower.y - actualHeight / 2); ctx.lineTo(tower.x + actualWidth / 2, tower.y - actualHeight / 2 - 10); ctx.lineTo(tower.x + actualWidth, tower.y - actualHeight / 2); ctx.closePath(); ctx.fill(); }
                 drawHealthBar(tower.x, healthBarY, actualWidth, healthBarHeight, tower.hp, tower.maxHp, true, tower.color === (playerTowers[1]?.color || '#3498db'));
                 const hpText = Math.max(0, Math.round(tower.hp)); const textX = tower.x + actualWidth / 2; const textY = healthBarY - 4;
                 ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 2;
                 ctx.font = tower.isKingTower ? '10px "Press Start 2P"' : '9px "Press Start 2P"';
                 ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                 ctx.strokeText(hpText, textX, textY); ctx.fillText(hpText, textX, textY);
             } else if (!tower.isKingTower) { drawRubble(tower.x, tower.y, tower.width * 0.9); }
        }
        function drawRubble(x, y, width) { /* ... (no changes) ... */
            if (!ctx) return; const rubbleColor = '#6c757d'; const pieceSize = width / 4;
            ctx.fillStyle = rubbleColor; const baseY = y + PRINCESS_TOWER_HEIGHT * 0.8 / 2 - pieceSize;
            ctx.fillRect(x + width * 0.1, baseY, pieceSize, pieceSize);
            ctx.fillRect(x + width * 0.6, baseY - pieceSize * 0.5, pieceSize * 1.2, pieceSize * 0.8);
            ctx.fillRect(x + width * 0.3, baseY - pieceSize, pieceSize * 0.8, pieceSize * 1.2);
            ctx.fillStyle = lightenColor(rubbleColor, -20);
            ctx.fillRect(x + width * 0.5, baseY - pieceSize * 0.5, pieceSize, pieceSize * 0.7);
        }
        function drawUnit(unit) { /* ... (no changes) ... */
            if (!ctx || !unit || !unit.stats || typeof unit.maxHp === 'undefined') return;
            ctx.fillStyle = unit.color;
            ctx.beginPath();
            const shape = unit.stats.shape || 'square';
            const size = unit.stats.size || 15;
            switch (shape) {
                case 'circle': ctx.arc(unit.x, unit.y, size / 2, 0, Math.PI * 2); ctx.fill(); break;
                case 'diamond': ctx.moveTo(unit.x, unit.y - size / 2); ctx.lineTo(unit.x + size / 2, unit.y); ctx.lineTo(unit.x, unit.y + size / 2); ctx.lineTo(unit.x - size / 2, unit.y); ctx.closePath(); ctx.fill(); break;
                case 'square': default: ctx.fillRect(unit.x - size / 2, unit.y - size / 2, size, size); break;
            }
            drawHealthBar(unit.x - size / 2, unit.y - size / 2 - 10, size, 5, unit.hp, unit.maxHp);
        }
        function drawBuilding(building) { /* ... (no changes) ... */
            if (!ctx || !building || !building.stats) return;
            const size = building.stats.size || 40;
            const healthBarY = building.y - size / 2 - 15;
            const healthBarHeight = 8;
            ctx.fillStyle = building.color;
            ctx.fillRect(building.x - size / 2, building.y - size / 2, size, size);
            ctx.fillStyle = lightenColor(building.color, -20);
            const barrelWidth = size * 0.2;
            const barrelLength = size * 0.4;
            const barrelX = building.x - barrelWidth / 2;
            const barrelY = building.y - size / 2 - barrelLength;
            ctx.fillRect(barrelX, barrelY, barrelWidth, barrelLength);
            drawHealthBar(building.x - size / 2, healthBarY, size, healthBarHeight, building.hp, building.maxHp);
        }
        function drawLogProjectile(log) { /* ... (no changes) ... */
            if (!ctx || !log) return;
            const width = log.stats.width;
            const length = 60; // Visual length of the log
            const angle = log.direction === 1 ? 0 : Math.PI;
            ctx.save(); ctx.translate(log.x, log.y); ctx.rotate(angle);
            ctx.fillStyle = log.color || '#8B4513';
            ctx.fillRect(-length / 2, -width / 2, length, width);
            ctx.fillStyle = lightenColor(log.color || '#8B4513', -20);
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(-length / 2 + i * (length/3), -width/2 - 2, length/4, 4);
                ctx.fillRect(-length / 2 + i * (length/3) + 5, width/2 -2, length/4, 4);
            }
            ctx.restore();
        }
        function drawHealthBar(x, y, width, height, currentHp, maxHp, isTowerBar = false, isPlayerTower = false) { /* ... (no changes) ... */
             if (!ctx) return; const validMaxHp = Math.max(1, maxHp); const hpPercent = Math.max(0, currentHp) / validMaxHp;
             ctx.fillStyle = isTowerBar ? '#7f8c8d' : '#e74c3c'; ctx.fillRect(x, y, width, height);
             ctx.fillStyle = isTowerBar ? (isPlayerTower ? '#3498db' : '#e74c3c') : '#2ecc71';
             ctx.fillRect(x, y, width * hpPercent, height);
             ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 1; ctx.strokeRect(x, y, width, height);
         }
        function drawProjectile(p) { /* ... (no changes) ... */ if (!ctx) return; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
        function lightenColor(hex, percent) { /* ... (no changes) ... */
            hex = hex.replace(/^\s*#|\s*$/g, ''); if(hex.length == 3){ hex = hex.replace(/(.)/g, '$1$1'); }
            var bigint = parseInt(hex, 16); var r = (bigint >> 16) & 255; var g = (bigint >> 8) & 255; var b = bigint & 255;
            r = Math.min(255, r + (255 * percent / 100)); g = Math.min(255, g + (255 * percent / 100)); b = Math.min(255, b + (255 * percent / 100));
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        function drawAttackEffects() { /* ... (no changes) ... */
            if (!ctx) return;
            const currentTime = Date.now();
            attackEffects.forEach(effect => {
                const elapsed = currentTime - effect.startTime;
                const progress = Math.min(1, elapsed / effect.duration);
                const alpha = 1 - progress;
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                if (effect.type === 'slash') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.9})`; ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(0, 255, 255, 0.7)'; ctx.shadowBlur = 5;
                    ctx.beginPath(); ctx.moveTo(effect.x1, effect.y1); ctx.lineTo(effect.x2, effect.y2); ctx.stroke();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                } else if (effect.type === 'flash') {
                    ctx.fillStyle = `rgba(255, 255, 150, ${alpha * 0.7})`; ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * (1 + progress * 0.5), 0, Math.PI * 2); ctx.fill();
                } else if (effect.type === 'explosion') {
                    const currentRadius = effect.radius * progress; ctx.fillStyle = effect.color || 'rgba(255, 100, 0, 0.8)';
                    ctx.beginPath(); ctx.arc(effect.x, effect.y, currentRadius, 0, Math.PI * 2); ctx.fill();
                    if (progress < 0.5) {
                        ctx.fillStyle = `rgba(255, 255, 150, ${alpha * 0.5})`; ctx.beginPath();
                        ctx.arc(effect.x, effect.y, currentRadius * 0.5, 0, Math.PI * 2); ctx.fill();
                    }
                }
                ctx.globalAlpha = 1.0; // Reset global alpha
            });
        }


        // --- Deck Building ---
        function renderCardLibrary() { /* ... (no changes) ... */
            if (!cardLibraryContainer) return;
            cardLibraryContainer.innerHTML = '';
            FULL_CARD_LIBRARY.forEach(card => {
                const cardElement = createCardElement(card, 'library');
                cardLibraryContainer.appendChild(cardElement);
            });
        }
        function renderSelectedDeck() { /* ... (no changes) ... */
            if (!selectedDeckContainer) return;
            selectedDeckContainer.innerHTML = '';
            selectedDeck.forEach((cardId, index) => {
                const card = getCardById(cardId);
                if (card) {
                    const cardElement = createCardElement(card, 'deck', index);
                    selectedDeckContainer.appendChild(cardElement);
                }
            });
            const placeholdersNeeded = DECK_SIZE - selectedDeck.length;
            for (let i = 0; i < placeholdersNeeded; i++) {
                const deckSlot = document.createElement('div');
                deckSlot.classList.add('deck-slot-placeholder');
                selectedDeckContainer.appendChild(deckSlot);
            }
            startBattleButton.disabled = selectedDeck.length !== DECK_SIZE;
            startBattleButton.textContent = selectedDeck.length === DECK_SIZE ? "Start Battle!" : `Select ${DECK_SIZE - selectedDeck.length} More Cards`;
        }
        function createCardElement(card, location, index = -1) { /* ... (no changes) ... */
            const cardElement = document.createElement('div');
            cardElement.classList.add('card');
            cardElement.dataset.id = card.id;
            cardElement.dataset.type = card.type; // Ensure type is set
            const costElement = document.createElement('div');
            costElement.classList.add('card-cost');
            costElement.textContent = card.cost;
            cardElement.appendChild(costElement);
            const iconContainer = document.createElement('div');
            iconContainer.classList.add('card-icon');
            if (card.imageUrl) {
                const imgElement = document.createElement('img');
                imgElement.src = card.imageUrl; imgElement.alt = card.name;
                imgElement.onerror = function() { this.onerror = null; this.style.display = 'none'; const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); };
                iconContainer.appendChild(imgElement);
            } else { const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); }
            cardElement.appendChild(iconContainer);
            const nameElement = document.createElement('div');
            nameElement.classList.add('card-name');
            nameElement.textContent = card.name;
            cardElement.appendChild(nameElement);
             if (!card.implemented) { cardElement.classList.add('disabled-card'); nameElement.textContent += " (N/A)"; }
            if (location === 'library' && card.implemented) { cardElement.addEventListener('click', () => { if (!selectedDeck.includes(card.id)) { addCardToDeck(card.id); } else { console.log(`${card.name} is already in the deck.`); } }); }
             else if (location === 'deck') { cardElement.addEventListener('click', () => removeCardFromDeck(index)); }
            return cardElement;
        }
        function addCardToDeck(cardId) { /* ... (no changes) ... */
            if (selectedDeck.length < DECK_SIZE) { selectedDeck.push(cardId); renderSelectedDeck(); }
             else { console.log("Deck is full!"); }
        }
        function removeCardFromDeck(index) { /* ... (no changes) ... */
             if (index >= 0 && index < selectedDeck.length) { selectedDeck.splice(index, 1); renderSelectedDeck(); }
              else { console.error("Invalid index for card removal:", index, selectedDeck); }
        }

        // --- Battle Logic ---
        function populateBattleControls() { /* ... (no changes) ... */
            if (!battleControlsContainer) return;
            battleControlsContainer.innerHTML = '';
            selectedDeck.forEach(cardId => {
                const card = getCardById(cardId);
                if (card) {
                    const button = document.createElement('button');
                    button.classList.add('deploy-button');
                    button.dataset.id = card.id;
                    button.dataset.type = card.type; // Set type for listener
                    button.dataset.cost = card.cost;
                    button.disabled = !card.implemented || playerElixir < card.cost;
                    const iconContainer = document.createElement('div'); iconContainer.classList.add('card-icon');
                    if (card.imageUrl) { /* ... image loading ... */
                        const imgElement = document.createElement('img'); imgElement.src = card.imageUrl; imgElement.alt = card.name;
                        imgElement.onerror = function() { this.onerror = null; this.style.display = 'none'; const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); };
                        iconContainer.appendChild(imgElement);
                    } else { /* ... fallback text ... */
                        const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback);
                    }
                    button.innerHTML = ` <div class="card-cost">${card.cost}</div> ${iconContainer.outerHTML} <div class="card-name">${card.name}${!card.implemented ? ' (N/A)' : ''}</div> `;
                    if(card.id === 'knight') button.style.backgroundImage = 'var(--button-silver-gradient)';
                    else if(card.id === 'bats') button.style.backgroundImage = 'var(--button-darkpurple-gradient)';
                    else if(card.id === 'skeletons') { button.style.backgroundImage = 'var(--button-white-gradient)'; button.style.color = '#333'; button.style.textShadow = 'none';}
                    else if(card.id === 'fireball' || card.id === 'hogrider') button.style.backgroundImage = 'var(--button-orange-gradient)'; // Hog uses orange too
                    else if(card.id === 'log') button.style.backgroundImage = 'var(--button-brown-gradient)';
                    else if(card.id === 'cannon') button.style.backgroundImage = 'var(--button-gray-gradient)';
                    battleControlsContainer.appendChild(button);
                }
            });
             // setupDeployButtonListeners called by override
        }
        function handleDeployAction(cardId, clickX, clickY) { /* ... (no changes) ... */
             const card = getCardById(cardId);
             if (!card || !card.implemented) { console.error("handleDeployAction called with invalid/unimplemented card:", cardId); return; };
             if (card.type === 'unit') { deployUnit(card.id, true); }
             else if (card.type === 'spell') {
                 if (card.id === 'log') { executeSpellEffect(card.id, clickX, clickY); }
                 else { startSpellTargeting(card.id); }
             } else if (card.type === 'building') { startBuildingPlacement(card.id); }
        }

        // --- Spell Logic ---
        function startSpellTargeting(spellId) { /* ... (no changes) ... */
             const spellCard = getCardById(spellId);
             if (isTargetingSpell || isPlacingBuilding || !canvas || !spellCard || spellCard.type !== 'spell' || spellId === 'log' || !spellCard.stats.radius) return;
             console.log(`Targeting ${spellId}...`);
             isTargetingSpell = true; currentSpellType = spellId; canvas.style.cursor = 'crosshair';
             updateBattleButtons();
             if (targetingIndicator && spellCard.stats.radius) {
                 const radius = spellCard.stats.radius;
                 targetingIndicator.style.width = `${radius * 2}px`;
                 targetingIndicator.style.height = `${radius * 2}px`;
                 targetingIndicator.style.display = 'block';
                 targetingIndicator.style.borderColor = 'var(--accent-red)';
                 targetingIndicator.style.backgroundColor = 'rgba(231, 76, 60, 0.2)';
                 canvas.addEventListener('mousemove', updateTargetingIndicator);
             }
             canvas.addEventListener('mousedown', handleSpellCast, { once: true });
        }
         function updateTargetingIndicator(event) { /* ... (no changes) ... */
             if (!isTargetingSpell || !currentSpellType || !targetingIndicator || !canvas) return;
             const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top;
             const indicatorSize = targetingIndicator.offsetWidth;
             const clampedX = Math.max(indicatorSize / 2, Math.min(canvas.width - indicatorSize / 2, x));
             const clampedY = Math.max(indicatorSize / 2, Math.min(canvas.height - indicatorSize / 2, y));
             targetingIndicator.style.left = `${clampedX - indicatorSize / 2}px`;
             targetingIndicator.style.top = `${clampedY - indicatorSize / 2}px`;
         }
        function handleSpellCast(event) { /* ... (no changes) ... */
             if (!isTargetingSpell || !currentSpellType || !canvas) return;
             event.preventDefault();
             const rect = canvas.getBoundingClientRect(); const targetX = event.clientX - rect.left; const targetY = event.clientY - rect.top;
             const spellCard = getCardById(currentSpellType);
             console.log(`Casting ${currentSpellType} at (${targetX.toFixed(0)}, ${targetY.toFixed(0)})`);
             setTimeout(() => { executeSpellEffect(currentSpellType, targetX, targetY); }, spellCard.stats.delay || 0);
             isTargetingSpell = false; currentSpellType = null; canvas.style.cursor = 'default';
             if (targetingIndicator) targetingIndicator.style.display = 'none';
             canvas.removeEventListener('mousemove', updateTargetingIndicator);
             updateBattleButtons();
        }

        // --- *** MODIFIED: executeSpellEffect with Log Y-position Fix *** ---
        function executeSpellEffect(spellId, x, y) { // x, y are click coordinates
            const spellCard = getCardById(spellId);
            if (!spellCard || spellCard.type !== 'spell') return;

            console.log(`%cExecuting ${spellId} effect at (${x.toFixed(0)}, ${y.toFixed(0)})`, "color: orange; font-weight: bold;");

            if (spellId === 'fireball') {
                const radius = spellCard.stats.radius;
                const damage = spellCard.stats.damage;
                const canTargetAir = spellCard.stats.targets?.includes('air');
                const canTargetGround = spellCard.stats.targets?.includes('ground');

                // Visual effect
                attackEffects.push({ type: 'explosion', x: x, y: y, radius: radius, duration: 400, startTime: Date.now(), color: 'rgba(255, 100, 0, 0.8)' });

                // Apply damage to enemies
                const targetsToCheck = [...enemyUnits, ...enemyTowers, ...enemyBuildings]; // Include buildings
                targetsToCheck.forEach(target => {
                    if (!target || target.hp <= 0) return;
                    // Check target type (air/ground) compatibility
                    const targetIsAir = target.stats?.isAir;
                    if (targetIsAir && !canTargetAir) return;
                    if (!targetIsAir && !canTargetGround) return;

                    const targetCenterX = target.x + (target.isTower || target.isBuilding ? target.width / 2 : 0);
                    const targetCenterY = target.y;
                    const dist = distance(x, y, targetCenterX, targetCenterY);

                    if (dist <= radius) {
                        console.log(`   -> ${spellId} HIT ${target.isTower ? 'tower' : target.isBuilding ? 'building' : target.type || 'unit'} (ID: ${target.id}) at distance ${dist.toFixed(1)}. HP before: ${target.hp.toFixed(0)}`);
                        target.hp -= damage;
                        console.log(`   -> HP after: ${target.hp.toFixed(0)}`);
                        attackEffects.push({ type: 'flash', x: targetCenterX, y: targetCenterY, radius: (target.width || target.stats?.size || 10) * 0.3, duration: 150, startTime: Date.now() });
                    }
                });

            } else if (spellId === 'log') {
                // Create a Log projectile instance
                const logStats = spellCard.stats;
                const startX = 0; // Start from player side edge

                // --- FIX: Set Y coordinate to the center of the canvas ---
                const logYPosition = canvas.height / 2;
                // --- End Fix ---

                logProjectiles.push({
                    id: `log_${Date.now()}`,
                    x: startX,
                    // y: y, // OLD: Used click Y coordinate, which was incorrect based on logs
                    y: logYPosition, // NEW: Use the calculated center Y position
                    startX: startX,
                    stats: logStats,
                    color: 'var(--log-color)',
                    direction: 1, // Player's log always moves right
                    startTime: Date.now(),
                    hitTargets: [] // Keep track of targets already hit by this log
                });
                // AI Log would start from other side (x=canvas.width), direction -1, y also canvas.height/2
            }

            updateDisplays();
            cleanupDeadUnits(); // Includes buildings now
        }


        // --- Building Placement Logic ---
        function startBuildingPlacement(buildingId) { /* ... (no changes) ... */
            const buildingCard = getCardById(buildingId);
            if (isTargetingSpell || isPlacingBuilding || !canvas || !buildingCard || buildingCard.type !== 'building') return;
            console.log(`Placing ${buildingId}...`);
            isPlacingBuilding = true; currentBuildingType = buildingId; canvas.style.cursor = 'copy';
            updateBattleButtons();
            const size = buildingCard.stats.size || PLACEMENT_TILE_SIZE;
            placementIndicator.style.width = `${size}px`; placementIndicator.style.height = `${size}px`;
            placementIndicator.style.display = 'block';
            canvas.addEventListener('mousemove', updatePlacementIndicator);
            canvas.addEventListener('mousedown', handleBuildingPlace, { once: true });
        }
        function updatePlacementIndicator(event) { /* ... (no changes) ... */
            if (!isPlacingBuilding || !currentBuildingType || !placementIndicator || !canvas) return;
            const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top;
            const card = getCardById(currentBuildingType); const size = card.stats.size || PLACEMENT_TILE_SIZE;
            const indicatorX = x - size / 2; const indicatorY = y - size / 2;
            placementIndicator.style.left = `${indicatorX}px`; placementIndicator.style.top = `${indicatorY}px`;
            if (isValidPlacement(x, y, true)) { placementIndicator.classList.remove('invalid'); }
            else { placementIndicator.classList.add('invalid'); }
        }
        function handleBuildingPlace(event) { /* ... (no changes) ... */
            if (!isPlacingBuilding || !currentBuildingType || !canvas) return;
            event.preventDefault();
            const rect = canvas.getBoundingClientRect(); const targetX = event.clientX - rect.left; const targetY = event.clientY - rect.top;
            if (isValidPlacement(targetX, targetY, true)) {
                console.log(`Placing ${currentBuildingType} at (${targetX.toFixed(0)}, ${targetY.toFixed(0)})`);
                deployBuilding(currentBuildingType, true, targetX, targetY);
            } else {
                console.log(`Invalid placement location for ${currentBuildingType}.`);
                playerElixir += getCardById(currentBuildingType).cost; updateDisplays();
            }
            isPlacingBuilding = false; currentBuildingType = null; canvas.style.cursor = 'default';
            if (placementIndicator) placementIndicator.style.display = 'none';
            canvas.removeEventListener('mousemove', updatePlacementIndicator);
            updateBattleButtons();
        }
        function isValidPlacement(x, y, isPlayer) { /* ... (no changes) ... */
            const card = getCardById(currentBuildingType); if (!card) return false;
            const size = card.stats.size || PLACEMENT_TILE_SIZE; const halfSize = size / 2;
            if (isPlayer && x > PLAYER_SIDE_X_LIMIT) return false;
            if (!isPlayer && x < PLAYER_SIDE_X_LIMIT) return false;
            if (x - halfSize < 0 || x + halfSize > canvas.width || y - halfSize < 0 || y + halfSize > canvas.height) return false;
            const checkEntities = isPlayer ? [...playerTowers, ...playerBuildings] : [...enemyTowers, ...enemyBuildings];
            const minDistance = size * 0.8;
            for (const entity of checkEntities) {
                 if (!entity || entity.hp <= 0) continue;
                 const entitySize = entity.isTower ? (entity.isKingTower ? KING_TOWER_WIDTH : PRINCESS_TOWER_WIDTH) : entity.stats?.size || PLACEMENT_TILE_SIZE;
                 const entityX = entity.x + (entity.isTower ? entity.width/2 : 0); const entityY = entity.y;
                 if (distance(x, y, entityX, entityY) < (halfSize + entitySize / 2 + 10)) { return false; }
            }
            return true;
        }


        function updateElixir() { /* ... (no changes) ... */
            if (gameOver || isTiebreakerActive) return;
            if (playerElixir < MAX_ELIXIR) { playerElixir = Math.min(MAX_ELIXIR, playerElixir + ELIXIR_REGEN_RATE); }
            aiElixir = Math.min(MAX_ELIXIR, aiElixir + ELIXIR_REGEN_RATE);
            updateDisplays(); updateBattleButtons();
        }
        function deployUnit(cardId, isPlayer) { /* ... (no changes) ... */
             const card = getCardById(cardId); if (!card || card.type !== 'unit') { console.error("Invalid unit type for deployment:", cardId); return; }
             const kingTower = isPlayer ? playerTowers[1] : enemyTowers[1];
             const spawnXBase = kingTower.x + (isPlayer ? kingTower.width + 20 : -20 - (card.stats.size || card.stats.unitStats?.size || 15));
             const spawnYBase = kingTower.y + (Math.random() * 80 - 40);
             if (card.stats.spawnCount && card.stats.unitStats) {
                 const unitStats = card.stats.unitStats; const spawnCount = card.stats.spawnCount; const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
                 for (let i = 0; i < spawnCount; i++) {
                     const spawnYOffset = (Math.random() - 0.5) * 30 * spawnCount; const spawnXOffset = (Math.random() - 0.5) * 10;
                     const newUnit = { id: `${cardId}_${Date.now()}_${Math.random()}_${i}`, type: cardId, stats: { ...unitStats }, x: spawnXBase + spawnXOffset, y: spawnYBase + spawnYOffset, isPlayer: isPlayer, hp: unitStats.hp, maxHp: unitStats.maxHp, color: isPlayer ? unitStats.color : enemyColor, target: null, lastAttackTime: 0, };
                     if (isPlayer) playerUnits.push(newUnit); else enemyUnits.push(newUnit);
                 }
             } else {
                 const stats = card.stats; const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
                 const newUnit = { id: `${cardId}_${Date.now()}_${Math.random()}`, type: cardId, stats: { ...stats }, x: spawnXBase, y: spawnYBase, isPlayer: isPlayer, hp: stats.hp, maxHp: stats.maxHp, color: isPlayer ? stats.color : enemyColor, target: null, lastAttackTime: 0, };
                 if (isPlayer) playerUnits.push(newUnit); else enemyUnits.push(newUnit);
             }
             console.log(`${isPlayer ? 'Player' : 'AI'} deployed ${card.name}`);
         }
        function deployBuilding(cardId, isPlayer, x, y) { /* ... (no changes) ... */
            const card = getCardById(cardId); if (!card || card.type !== 'building') { console.error("Invalid building type for deployment:", cardId); return; }
            const stats = card.stats; const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
            const newBuilding = { id: `${cardId}_${Date.now()}_${Math.random()}`, type: cardId, stats: { ...stats }, x: x, y: y, isPlayer: isPlayer, hp: stats.hp, maxHp: stats.maxHp, color: isPlayer ? stats.color : enemyColor, target: null, lastAttackTime: 0, spawnTime: Date.now(), isBuilding: true, width: stats.size, height: stats.size };
            if (isPlayer) { playerBuildings.push(newBuilding); } else { enemyBuildings.push(newBuilding); }
            console.log(`${isPlayer ? 'Player' : 'AI'} deployed building ${card.name}`);
        }


        // --- Targeting, Movement, Attack Logic ---
        function findTarget(unit, potentialEnemyUnits, potentialEnemyTowers, potentialEnemyBuildings) { /* ... (no changes) ... */
             let closestTarget = null; let minDistance = Infinity; if (!unit || !unit.stats || unit.hp <= 0) return null;
             const unitRange = unit.stats.range; const preference = unit.stats.targetPreference;
             const canTargetAir = unit.stats.targets?.includes('air') ?? true; const canTargetGround = unit.stats.targets?.includes('ground') ?? true;
             let preferredTargets = []; let otherTargets = [];
             const allEnemies = [...potentialEnemyUnits, ...potentialEnemyTowers, ...potentialEnemyBuildings];
             allEnemies.forEach(target => {
                 if (!target || target.hp <= 0) return;
                 const targetIsAir = target.stats?.isAir; const targetIsBuilding = target.isBuilding || target.isTower;
                 if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 if (preference === 'building' && targetIsBuilding) { preferredTargets.push(target); }
                 else if (preference !== 'building' || !targetIsBuilding) { otherTargets.push(target); }
             });
             preferredTargets.forEach(target => {
                 const targetCenterX = target.x + (target.width ? target.width / 2 : 0); const targetCenterY = target.y;
                 const d = distance(unit.x, unit.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; }
             });
             if (!closestTarget || minDistance > unitRange) {
                 if (minDistance > unitRange) minDistance = Infinity;
                 otherTargets.forEach(target => {
                     const targetCenterX = target.x + (target.width ? target.width / 2 : 0); const targetCenterY = target.y;
                     const d = distance(unit.x, unit.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; }
                 });
             }
             if (closestTarget && minDistance > unitRange) { return null; }
             return closestTarget;
        }
         function findTowerTarget(tower, potentialEnemyUnits, potentialEnemyBuildings) { /* ... (no changes) ... */
             let closestTarget = null; let minDistance = tower.range; if (!tower || tower.hp <= 0) return null;
             const canTargetAir = tower.targets?.includes('air'); const canTargetGround = tower.targets?.includes('ground');
             const allEnemies = [...potentialEnemyUnits, ...potentialEnemyBuildings];
             allEnemies.forEach(target => {
                  if(!target || target.hp <= 0) return;
                  const targetIsAir = target.stats?.isAir; if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 const targetCenterX = target.x + (target.isBuilding ? target.width / 2 : 0); const targetCenterY = target.y;
                 const d = distance(tower.x + tower.width / 2, tower.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; }
             });
             return closestTarget;
         }
         function findBuildingTarget(building, potentialEnemyUnits) { /* ... (no changes) ... */
             let closestTarget = null; let minDistance = building.stats.range; if (!building || building.hp <= 0) return null;
             const canTargetAir = building.stats.targets?.includes('air'); const canTargetGround = building.stats.targets?.includes('ground');
             potentialEnemyUnits.forEach(target => {
                  if(!target || target.hp <= 0) return;
                  const targetIsAir = target.stats?.isAir; if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 const d = distance(building.x, building.y, target.x, target.y); if (d < minDistance) { minDistance = d; closestTarget = target; }
             });
             return closestTarget;
         }
        function updateUnits(units, enemyUnitsList, enemyTowersList, enemyBuildingsList) { /* ... (no changes) ... */
            if (isTiebreakerActive) return; const currentTime = Date.now();
            for (let i = units.length - 1; i >= 0; i--) {
                const unit = units[i]; if (!unit || unit.hp <= 0 || !unit.stats) continue;
                if (unit.isPushedBack && currentTime < unit.pushbackEndTime) {
                    unit.x += unit.pushbackVelocityX; unit.y += unit.pushbackVelocityY;
                    unit.x = Math.max(unit.stats.size / 2, Math.min(canvas.width - unit.stats.size / 2, unit.x));
                    unit.y = Math.max(unit.stats.size / 2, Math.min(canvas.height - unit.stats.size / 2, unit.y)); continue;
                } else if (unit.isPushedBack) { unit.isPushedBack = false; }
                 let targetNeedsUpdate = !unit.target || unit.target.hp <= 0; if (targetNeedsUpdate) { unit.target = findTarget(unit, enemyUnitsList, enemyTowersList, enemyBuildingsList); }
                let isAttacking = false;
                if (unit.target) {
                    const targetWidth = unit.target.width || (unit.target.stats ? unit.target.stats.size : 0);
                    const targetCenterX = unit.target.x + (targetWidth / 2); const targetCenterY = unit.target.y;
                    const distToTarget = distance(unit.x, unit.y, targetCenterX, targetCenterY);
                    if (distToTarget <= unit.stats.range) {
                        isAttacking = true;
                        if (currentTime - unit.lastAttackTime >= unit.stats.attackSpeed) {
                             if (unit.stats.range > 30) { /* Ranged Attack */ projectiles.push({ x: unit.x, y: unit.y, target: unit.target, speed: 5, damage: unit.stats.damage, color: unit.color, size: 5, isPlayerProjectile: unit.isPlayer }); attackEffects.push({ type: 'flash', x: unit.x, y: unit.y, radius: unit.stats.size / 3, duration: 100, startTime: currentTime }); }
                             else { /* Melee Attack */ unit.target.hp -= unit.stats.damage; const angleToTarget = Math.atan2(targetCenterY - unit.y, targetCenterX - unit.x); const slashLength = unit.stats.size * 0.8; attackEffects.push({ type: 'slash', x1: unit.x + Math.cos(angleToTarget - Math.PI / 6) * unit.stats.size * 0.4, y1: unit.y + Math.sin(angleToTarget - Math.PI / 6) * unit.stats.size * 0.4, x2: unit.x + Math.cos(angleToTarget + Math.PI / 6) * slashLength, y2: unit.y + Math.sin(angleToTarget + Math.PI / 6) * slashLength, duration: 150, startTime: currentTime }); }
                             unit.lastAttackTime = currentTime; if (unit.target.hp <= 0) { unit.target = null; isAttacking = false; }
                        }
                    } else { unit.target = null; isAttacking = false; }
                }
                 if (!isAttacking) {
                     let moveTarget = unit.target; if (!moveTarget) { moveTarget = findTarget(unit, enemyUnitsList, enemyTowersList, enemyBuildingsList); }
                     if (moveTarget) { const targetCenterX = moveTarget.x + (moveTarget.width ? moveTarget.width / 2 : 0); const angle = Math.atan2(moveTarget.y - unit.y, targetCenterX - unit.x); unit.x += Math.cos(angle) * unit.stats.speed; unit.y += Math.sin(angle) * unit.stats.speed; }
                     else { const direction = unit.isPlayer ? 1 : -1; unit.x += unit.stats.speed * direction; }
                 }
                 unit.x = Math.max(unit.stats.size / 2, Math.min(canvas.width - unit.stats.size / 2, unit.x));
                 unit.y = Math.max(unit.stats.size / 2, Math.min(canvas.height - unit.stats.size / 2, unit.y));
            }
        }
         function updateTowers(towers, enemyUnitsList, enemyBuildingsList) { /* ... (no changes) ... */
             if (isTiebreakerActive) return; const currentTime = Date.now();
             towers.forEach(tower => {
                 if (tower.hp > 0) {
                     const target = findTowerTarget(tower, enemyUnitsList, enemyBuildingsList);
                     if (target && currentTime - tower.lastAttackTime >= tower.attackSpeed) {
                         const projectileStartX = tower.x + tower.width / 2;
                         projectiles.push({ x: projectileStartX, y: tower.y, target: target, speed: 6, damage: tower.damage, color: tower.color, size: 6, isPlayerProjectile: tower.color === playerTowers[1].color });
                         tower.lastAttackTime = currentTime; attackEffects.push({ type: 'flash', x: projectileStartX, y: tower.y, radius: 4, duration: 100, startTime: currentTime });
                     }
                 }
             });
         }
         function updateBuildings(buildings, enemyUnitsList) { /* ... (no changes) ... */
             if (isTiebreakerActive) return; const currentTime = Date.now();
             for (let i = buildings.length - 1; i >= 0; i--) {
                 const building = buildings[i]; if (!building || building.hp <= 0) continue;
                 if (currentTime - building.spawnTime > building.stats.lifetime) {
                     building.hp = 0; console.log(`${building.type} ${building.id} expired.`);
                     attackEffects.push({ type: 'flash', x: building.x, y: building.y, radius: building.stats.size / 2, duration: 300, startTime: currentTime }); continue;
                 }
                 const target = findBuildingTarget(building, enemyUnitsList);
                 if (target && currentTime - building.lastAttackTime >= building.stats.attackSpeed) {
                     const projectileStartX = building.x; const projectileStartY = building.y;
                     projectiles.push({ x: projectileStartX, y: projectileStartY, target: target, speed: 7, damage: building.stats.damage, color: building.color, size: 7, isPlayerProjectile: building.isPlayer });
                     building.lastAttackTime = currentTime; attackEffects.push({ type: 'flash', x: projectileStartX, y: projectileStartY, radius: 5, duration: 100, startTime: currentTime });
                 }
             }
         }

        // --- *** MODIFIED: updateLogProjectiles Logic with DEBUG LOGS COMMENTED OUT *** ---
        function updateLogProjectiles(logProjectilesList, enemyUnitsList, playerUnitsList) {
            if (isTiebreakerActive) return;
            const currentTime = Date.now();

            for (let i = logProjectilesList.length - 1; i >= 0; i--) {
                const log = logProjectilesList[i];
                if (!log) continue;

                // Move the log
                log.x += log.stats.speed * log.direction;

                // Check for collisions with ground units
                const unitsToCheck = log.direction === 1 ? enemyUnitsList : playerUnitsList;
                const logRect = {
                    x: log.x - 30, // Visual length/2
                    y: log.y - log.stats.width / 2,
                    width: 60, // Visual length
                    height: log.stats.width
                };

                unitsToCheck.forEach(unit => {
                    // --- DIAGNOSTIC LOG 1 (Commented Out) ---
                    // console.log(`Log Check: Unit ${unit?.id} (${unit?.type}), HP=${unit?.hp}, isGround=${isGroundUnit(unit)}, alreadyHit=${log.hitTargets.includes(unit?.id)}`);

                    if (!unit || unit.hp <= 0 || !isGroundUnit(unit) || log.hitTargets.includes(unit.id)) return; // Skip air, dead, or already hit units

                    const unitRect = {
                        x: unit.x - unit.stats.size / 2,
                        y: unit.y - unit.stats.size / 2,
                        width: unit.stats.size,
                        height: unit.stats.size
                    };

                    // --- DIAGNOSTIC LOG 2 (Commented Out) ---
                    // console.log(`Log Collision Check: Log Rect (x:${logRect.x.toFixed(1)}, y:${logRect.y.toFixed(1)}, w:${logRect.width}, h:${logRect.height}) vs Unit ${unit.id} Rect (x:${unitRect.x.toFixed(1)}, y:${unitRect.y.toFixed(1)}, w:${unitRect.width}, h:${unitRect.height})`);

                    // Simple AABB collision check
                    if (logRect.x < unitRect.x + unitRect.width &&
                        logRect.x + logRect.width > unitRect.x &&
                        logRect.y < unitRect.y + unitRect.height &&
                        logRect.y + logRect.height > unitRect.y)
                    {
                        // --- DIAGNOSTIC LOG 3 (Commented Out) ---
                        // console.log(`%c!!! LOG HIT DETECTED: Log ${log.id} hit Unit ${unit.id} !!!`, "color: lime; font-weight: bold;");

                        // Collision detected!
                        unit.hp -= log.stats.damage; // Apply Damage
                        log.hitTargets.push(unit.id); // Prevent hitting the same unit multiple times
                        // console.log(`   -> Unit ${unit.id} HP after Log hit: ${unit.hp.toFixed(0)}`); // Keep this log maybe?

                        // Apply pushback
                        const pushbackAngle = Math.atan2(unit.y - log.y, unit.x - log.x); // Push away from log center
                        const pushSpeed = log.stats.pushbackStrength;
                        unit.isPushedBack = true;
                        unit.pushbackEndTime = currentTime + log.stats.pushbackDuration;
                        unit.pushbackVelocityX = Math.cos(pushbackAngle) * pushSpeed;
                        unit.pushbackVelocityY = Math.sin(pushbackAngle) * pushSpeed;

                        // Add hit flash
                        attackEffects.push({ type: 'flash', x: unit.x, y: unit.y, radius: unit.stats.size / 2, duration: 150, startTime: currentTime });
                    }
                });

                // Remove log if it travels its distance or goes off-screen
                const distanceTraveled = Math.abs(log.x - log.startX);
                if (distanceTraveled >= log.stats.travelDistance || log.x < -logRect.width || log.x > canvas.width + logRect.width) {
                    logProjectilesList.splice(i, 1);
                }
            }
        }


        function updateProjectiles() { /* ... (no changes) ... */
             if (isTiebreakerActive) return;
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); continue; }
                const targetWidth = p.target.isTower || p.target.isBuilding ? p.target.width : (p.target.stats ? p.target.stats.size : 0);
                const targetX = p.target.x + (targetWidth / 2); const targetY = p.target.y;
                const angle = Math.atan2(targetY - p.y, targetX - p.x);
                p.x += Math.cos(angle) * p.speed; p.y += Math.sin(angle) * p.speed;
                const hitRadius = (targetWidth || p.target.stats?.size || 10) / 2 * 0.8;
                if (distance(p.x, p.y, targetX, targetY) < hitRadius) {
                     p.target.hp -= p.damage;
                     attackEffects.push({ type: 'flash', x: targetX, y: targetY, radius: hitRadius * 1.5, duration: 100, startTime: Date.now() });
                     projectiles.splice(i, 1);
                 }
                 else if (p.x < -p.size || p.x > canvas.width + p.size || p.y < -p.size || p.y > canvas.height + p.size) { projectiles.splice(i, 1); }
            }
        }
         function cleanupDeadUnits() { /* ... (no changes) ... */
             playerUnits = playerUnits.filter(unit => unit && unit.hp > 0);
             enemyUnits = enemyUnits.filter(unit => unit && unit.hp > 0);
             playerBuildings = playerBuildings.filter(building => building && building.hp > 0);
             enemyBuildings = enemyBuildings.filter(building => building && building.hp > 0);
         }
         function updateAttackEffects(currentTime) { /* ... (no changes) ... */
             attackEffects = attackEffects.filter(effect => currentTime - effect.startTime <= effect.duration);
         }
         function simpleAI() { /* ... (no changes) ... */
             if (gameOver || isTiebreakerActive || isPlacingBuilding || isTargetingSpell) return;
             if (aiElixir >= getCardById('cannon').cost) {
                  let needsDefense = false; playerUnits.forEach(unit => { if (distance(unit.x, unit.y, enemyTowers[1].x + enemyTowers[1].width/2, enemyTowers[1].y) < 250) { needsDefense = true; } });
                  if (needsDefense && enemyBuildings.length < 2) {
                      const placeX = enemyTowers[1].x - 50; const placeY = canvas.height / 2 + (Math.random() * 100 - 50);
                      if (isValidPlacement(placeX, placeY, false)) {
                          aiElixir -= getCardById('cannon').cost; deployBuilding('cannon', false, placeX, placeY); console.log("AI deployed defensive Cannon"); updateDisplays(); updateBattleButtons(); return;
                      }
                  }
             }
             if (aiElixir >= getCardById('hogrider').cost + 3 && Math.random() < 0.3) {
                 aiElixir -= getCardById('hogrider').cost; deployUnit('hogrider', false); console.log("AI deployed Hog Rider"); updateDisplays(); updateBattleButtons(); return;
             }
             const deployableUnitCards = FULL_CARD_LIBRARY.filter(card => card.implemented && card.type === 'unit' && card.id !== 'hogrider'); if (deployableUnitCards.length === 0) return;
             const affordableCards = deployableUnitCards.filter(card => aiElixir >= card.cost);
             if (affordableCards.length > 0) {
                 const randomCard = affordableCards[Math.floor(Math.random() * affordableCards.length)]; aiElixir -= randomCard.cost; deployUnit(randomCard.id, false); updateDisplays(); updateBattleButtons();
             }
         }


         // --- Game Over Check ---
         function checkGameOver(timeUp = false) { /* ... (no changes) ... */
             if (gameOver) return; let winner = null;
             const playerKingTower = playerTowers[1]; const enemyKingTower = enemyTowers[1];
             if (enemyKingTower.hp <= 0) { winner = 'Player'; } else if (playerKingTower.hp <= 0) { winner = 'Enemy'; }
             else if (timeUp && !isTiebreakerActive) {
                 console.log("Time's up! Checking tower HP for tiebreaker.");
                 if (playerKingTower.hp > enemyKingTower.hp) { winner = 'Player'; } else if (enemyKingTower.hp > playerKingTower.hp) { winner = 'Enemy'; } else { startTiebreaker(); return; }
             }
             if (winner) {
                 gameOver = true; stopGameTimers(); console.log("Game Over! Winner:", winner);
                 if (winner === 'Player') { showMessage("You Win!"); } else if (winner === 'Enemy') { showMessage("You Lose!"); }
                 updateBattleButtons(); console.log("Switching back to deck builder in 3 seconds..."); setTimeout(switchToDeckBuilder, 3000);
             }
         }

         // --- Tiebreaker Functions ---
         function startTiebreaker() { /* ... (no changes) ... */
             if (isTiebreakerActive) return; console.log("TIEBREAKER STARTED!"); isTiebreakerActive = true;
             clearInterval(elixirIntervalId); elixirIntervalId = null; clearInterval(aiIntervalId); aiIntervalId = null; clearInterval(gameTimerIntervalId); gameTimerIntervalId = null;
             playerUnits = []; enemyUnits = []; projectiles = []; logProjectiles = []; playerBuildings = []; enemyBuildings = []; attackEffects = [];
             updateBattleButtons(); showMessage("TIEBREAKER!"); setTimeout(hideMessage, 2000);
             if (tiebreakerIntervalId) clearInterval(tiebreakerIntervalId); tiebreakerIntervalId = setInterval(drainTowerHp, TIEBREAKER_DRAIN_INTERVAL);
         }
         function drainTowerHp() { /* ... (no changes) ... */
             if (!isTiebreakerActive || gameOver) { stopGameTimers(); return; } const drainAmount = TIEBREAKER_HP_DRAIN_RATE;
             playerTowers[1].hp -= drainAmount; enemyTowers[1].hp -= drainAmount; updateDisplays(); checkGameOver();
         }

         // --- stopGameTimers ---
        function stopGameTimers() { /* ... (no changes) ... */
             clearInterval(elixirIntervalId); elixirIntervalId = null; clearInterval(aiIntervalId); aiIntervalId = null; clearInterval(gameTimerIntervalId); gameTimerIntervalId = null; clearInterval(tiebreakerIntervalId); tiebreakerIntervalId = null;
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
             isTargetingSpell = false; currentSpellType = null; isPlacingBuilding = false; currentBuildingType = null;
             if(canvas) { canvas.style.cursor = 'default'; canvas.removeEventListener('mousemove', updateTargetingIndicator); canvas.removeEventListener('mousemove', updatePlacementIndicator); }
             if (targetingIndicator) targetingIndicator.style.display = 'none'; if (placementIndicator) placementIndicator.style.display = 'none';
             console.log("Game timers and animation frame stopped.");
        }

        // --- Timer Logic ---
        function startGameTimer() { /* ... (no changes) ... */
            gameTimeRemaining = BATTLE_DURATION_SECONDS; updateTimerDisplay(); if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            gameTimerIntervalId = setInterval(() => { if (gameOver) { stopGameTimers(); return; } gameTimeRemaining--; updateTimerDisplay(); if (gameTimeRemaining <= 0 && !gameOver && !isTiebreakerActive) { checkGameOver(true); } }, 1000);
        }
        function updateTimerDisplay() { /* ... (no changes) ... */
            if (!gameTimerDisplay) return; const minutes = Math.floor(Math.max(0, gameTimeRemaining) / 60); const seconds = Math.max(0, gameTimeRemaining) % 60; gameTimerDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // --- Displays and Buttons ---
        function updateDisplays() { /* ... (no changes) ... */
            if (!playerElixirDisplaySpan || !playerTowerHpDisplay || !enemyTowerHpDisplay || !playerElixirBarFill) return;
            playerElixirDisplaySpan.textContent = `Elixir: ${playerElixir} / ${MAX_ELIXIR}`;
            const playerKingHp = playerTowers[1] ? Math.max(0, Math.round(playerTowers[1].hp)) : 'N/A';
            const enemyKingHp = enemyTowers[1] ? Math.max(0, Math.round(enemyTowers[1].hp)) : 'N/A';
            playerTowerHpDisplay.textContent = `King HP: ${playerKingHp}/${KING_TOWER_HP}`;
            enemyTowerHpDisplay.textContent = `King HP: ${enemyKingHp}/${KING_TOWER_HP}`;
            const elixirPercentage = (playerElixir / MAX_ELIXIR) * 100; playerElixirBarFill.style.width = `${elixirPercentage}%`;
        }
         function updateBattleButtons() { /* ... (no changes) ... */
             const buttons = battleControlsContainer ? battleControlsContainer.querySelectorAll('.deploy-button') : [];
             buttons.forEach(button => {
                 const cardId = button.dataset.id; const card = getCardById(cardId);
                 if (card) { button.disabled = !card.implemented || playerElixir < card.cost || gameOver || isTiebreakerActive || isTargetingSpell || isPlacingBuilding; }
                 else { button.disabled = true; }
             });
         }
        function showMessage(text) { /* ... (no changes) ... */ if(messageBox) { messageBox.textContent = text; messageBox.style.display = 'block'; } }
        function hideMessage() { /* ... (no changes) ... */ if(messageBox) messageBox.style.display = 'none'; }

        // --- Game Loop ---
        function gameLoop() { /* ... (no changes) ... */
            if (gameOver) { animationFrameId = null; return; } const currentTime = Date.now(); if (!ctx) { console.error("Canvas context lost during loop!"); stopGameTimers(); return; }
            try { /* Update Phase */
                if (!isTiebreakerActive) {
                    updateProjectiles(); updateLogProjectiles(logProjectiles, enemyUnits, playerUnits);
                    updateUnits(playerUnits, enemyUnits, enemyTowers, enemyBuildings); updateUnits(enemyUnits, playerUnits, playerTowers, playerBuildings);
                    updateTowers(playerTowers, enemyUnits, enemyBuildings); updateTowers(enemyTowers, playerUnits, playerBuildings);
                    updateBuildings(playerBuildings, enemyUnits); updateBuildings(enemyBuildings, playerUnits); cleanupDeadUnits();
                } updateAttackEffects(currentTime); updateDisplays();
            } catch (error) { console.error("Error during game update:", error); stopGameTimers(); showMessage("An error occurred!"); return; }
            ctx.clearRect(0, 0, canvas.width, canvas.height); /* Drawing Phase */
            try {
                playerTowers.forEach(drawTower); enemyTowers.forEach(drawTower); playerBuildings.forEach(drawBuilding); enemyBuildings.forEach(drawBuilding);
                if (!isTiebreakerActive) { playerUnits.forEach(drawUnit); enemyUnits.forEach(drawUnit); projectiles.forEach(drawProjectile); logProjectiles.forEach(drawLogProjectile); }
                else { /* Tiebreaker drawing */ tiebreakerEffectCounter++; if (tiebreakerEffectCounter % 30 < 15) { /* ... */ } } drawAttackEffects();
            } catch (error) { console.error("Error during game drawing:", error); stopGameTimers(); showMessage("An error occurred during drawing!"); return; }
            if (!isTiebreakerActive) { checkGameOver(false); } /* Post-Draw Checks */
            if (!gameOver) { animationFrameId = requestAnimationFrame(gameLoop); } else { animationFrameId = null; } /* Loop Continuation */
        }


        // --- Initialization ---
        function initializeGame() { /* ... (no changes) ... */
             console.log("Initializing Battle..."); gameOver = false; playerElixir = 3; aiElixir = AI_STARTING_ELIXIR;
             playerUnits = []; enemyUnits = []; playerBuildings = []; enemyBuildings = []; projectiles = []; logProjectiles = []; attackEffects = [];
             playerTowers = createTowers(true); enemyTowers = createTowers(false); gameTimeRemaining = BATTLE_DURATION_SECONDS;
             isTiebreakerActive = false; tiebreakerEffectCounter = 0; isTargetingSpell = false; currentSpellType = null; isPlacingBuilding = false; currentBuildingType = null;
             hideMessage(); stopGameTimers(); populateBattleControls(); updateDisplays(); updateBattleButtons();
             if (ctx) { console.log("Drawing initial state..."); ctx.clearRect(0, 0, canvas.width, canvas.height); playerTowers.forEach(drawTower); enemyTowers.forEach(drawTower); }
             else { console.error("Cannot draw initial state - context missing."); return; }
             console.log("Starting game intervals and loop..."); elixirIntervalId = setInterval(updateElixir, ELIXIR_REGEN_INTERVAL); aiIntervalId = setInterval(simpleAI, AI_DEPLOY_INTERVAL); startGameTimer();
             if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); console.log("Battle Started!");
        }

        // --- Screen Switching Logic ---
        function switchToDeckBuilder() { /* ... (no changes) ... */
            console.log("Switching to Deck Builder..."); stopGameTimers(); hideMessage(); if (deckBuilderScreen) deckBuilderScreen.classList.add('active'); if (battleScreen) battleScreen.classList.remove('active'); renderSelectedDeck();
        }
        function switchToBattle() { /* ... (no changes) ... */
            if (selectedDeck.length !== DECK_SIZE) { showMessage(`Please select exactly ${DECK_SIZE} cards!`); setTimeout(hideMessage, 2500); return; }
            console.log("Switching to Battle Screen..."); if (deckBuilderScreen) deckBuilderScreen.classList.remove('active'); if (battleScreen) battleScreen.classList.add('active'); initializeGame();
        }

        // --- Event Listeners Setup ---
        function setupDeployButtonListeners() { /* ... (no changes) ... */
            const buttons = battleControlsContainer ? battleControlsContainer.querySelectorAll('.deploy-button') : [];
            buttons.forEach(button => {
                 const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button);
                 const cardId = newButton.dataset.id; const cardType = newButton.dataset.type; const cardCost = parseInt(newButton.dataset.cost || '99'); const card = getCardById(cardId);
                 if (card && card.implemented) {
                     newButton.addEventListener('click', (event) => {
                         if (!gameOver && !isTiebreakerActive && !isTargetingSpell && !isPlacingBuilding && card.implemented && playerElixir >= cardCost) {
                             console.log(`Attempting Use: ${cardId}. Type: ${cardType}. Elixir=${playerElixir}, Cost=${cardCost}`); playerElixir -= cardCost; updateDisplays(); updateBattleButtons();
                             const rect = canvas.getBoundingClientRect(); const clickX = event ? event.clientX - rect.left : PLAYER_SIDE_X_LIMIT / 2; const clickY = event ? event.clientY - rect.top : canvas.height / 2;
                             handleDeployAction(cardId, clickX, clickY);
                         } else { console.log(`Cannot use ${cardId}. Conditions: Elixir=${playerElixir}, Cost=${cardCost}, Implemented=${card?.implemented}, GameOver=${gameOver}, Tiebreaker=${isTiebreakerActive}, Targeting=${isTargetingSpell}, Placing=${isPlacingBuilding}`); }
                     });
                 } else { newButton.disabled = true; }
            });
        }
        if (startBattleButton) startBattleButton.addEventListener('click', switchToBattle);
        if (resetButton) resetButton.addEventListener('click', switchToDeckBuilder);

        // --- Initial Setup on Load ---
        window.onload = () => { /* ... (no changes) ... */
             console.log("Window loaded. Setting up Deck Builder.");
             if (!deckBuilderScreen || !battleScreen || !cardLibraryContainer || !selectedDeckContainer || !canvas || !ctx || !startBattleButton || !resetButton || !gameTimerDisplay || !playerElixirDisplaySpan || !playerElixirBarFill || !placementIndicator) {
                 console.error("Essential DOM elements not found! Aborting setup."); document.body.innerHTML = '<h1 style="color:red; text-align: center;">Error loading game elements. Please refresh the page.</h1>'; return;
             } try { renderCardLibrary(); renderSelectedDeck(); deckBuilderScreen.classList.add('active'); battleScreen.classList.remove('active'); console.log("Deck Builder setup complete."); }
             catch (error) { console.error("Error during initial setup:", error); document.body.innerHTML = '<h1 style="color:red; text-align: center;">An error occurred during setup. Please refresh.</h1>'; }
        };

        // Override populateBattleControls to ensure listeners are re-attached
        const originalPopulateBattleControls = populateBattleControls;
        populateBattleControls = () => {
            originalPopulateBattleControls();
            setTimeout(setupDeployButtonListeners, 0);
        };

    </script>

</body>
</html>

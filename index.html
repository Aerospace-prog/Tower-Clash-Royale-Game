<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="./img/CRlogo.png">
    <title>Simple Tower Clash</title> <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- CSS (No Changes) --- */
        :root {
            --primary-bg: #1e2a3a; --secondary-bg: #2c3e50; --tertiary-bg: #3b5970;
            --accent-blue: #3498db; --accent-red: #e74c3c; --accent-green: #2ecc71;
            --accent-purple: #9b59b6; --accent-yellow: #f1c40f; --accent-gray: #7f8c8d;
            --text-light: #ecf0f1; --text-dark: #2c3e50; --border-color: #1a2531;
            --card-bg: #4a6883; --elixir-color: var(--accent-purple);
            --knight-color: '#bdc3c7'; --skeletons-color: '#ecf0f1'; --bats-color: '#512E5F';
            --hog-color: '#f39c12'; /* Hog Rider */
            --log-color: '#8B4513'; /* The Log */
            --cannon-color: '#95a5a6'; /* Cannon */


            --bg-gradient: linear-gradient(to bottom, #23344a, #1a2a3a);
            --container-gradient: linear-gradient(to bottom, #3a4c60, #2c3e50);
            --button-blue-gradient: linear-gradient(to bottom, #5dade2, #3498db);
            --button-green-gradient: linear-gradient(to bottom, #58d68d, #2ecc71);
            --button-gray-gradient: linear-gradient(to bottom, #95a5a6, #7f8c8d); /* Cannon uses this */
            --button-purple-gradient: linear-gradient(to bottom, #af7ac5, #9b59b6);
            --button-red-gradient: linear-gradient(to bottom, #ec7063, #e74c3c);
            --button-white-gradient: linear-gradient(to bottom, #f8f9f9, #e5e7e9);
            --button-silver-gradient: linear-gradient(to bottom, #e5e7e9, #bdc3c7); /* Knight */
            --button-darkpurple-gradient: linear-gradient(to bottom, #7d3c98, #512e5f); /* Bats */
            --button-orange-gradient: linear-gradient(to bottom, #f5b041, #f39c12); /* Fireball / Hog */
            --button-brown-gradient: linear-gradient(to bottom, #a05a2c, #8B4513); /* Log */
            --canvas-gradient: linear-gradient(to bottom, #bdc3c7, #95a5a6);
        }
        body {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            min-height: 100vh; background-color: var(--primary-bg); background-image: var(--bg-gradient);
            font-family: 'Press Start 2P', cursive; color: var(--text-light); margin: 0; padding-top: 20px; overflow-x: hidden;
        }
        /* Screen Containers */
        .screen { display: none; width: 100%; max-width: 900px; padding: 20px; border: 5px solid var(--border-color); background-color: var(--secondary-bg); border-radius: 15px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4); margin: 15px; box-sizing: border-box; }
        .screen.active { display: block; }
        /* General Styles */
        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-red); text-shadow: 2px 2px #000; }
        h1 { font-size: 1.8em; margin-top: 0; }
        h2 { font-size: 1.4em; color: var(--accent-blue); }
        button { /* Base button style */
            font-family: 'Press Start 2P', cursive; padding: 10px 18px; border: none; border-radius: 8px;
            cursor: pointer; background-color: var(--accent-blue); color: white; text-shadow: 1px 1px #000;
            transition: all 0.2s ease; box-shadow: 0 4px #1f618d; font-size: 0.9em;
        }
        button:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-1px); box-shadow: 0 5px #1f618d; }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: 0 2px #1f618d; }
        button:disabled { background-color: var(--accent-gray); cursor: not-allowed; box-shadow: 0 4px #566573; opacity: 0.7; }
        #resetButton { background-image: var(--button-red-gradient); border: 2px solid rgba(0,0,0,0.5); border-top-color: rgba(255,255,255,0.2); border-left-color: rgba(255,255,255,0.2); box-shadow: 0 5px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #resetButton:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 7px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #resetButton:active:not(:disabled) { transform: translateY(2px); filter: brightness(0.9); box-shadow: 0 2px 0px rgba(0,0,0,0.3), inset 0 2px 3px rgba(0,0,0,0.3); }

        /* Deck Builder Screen */
        #deckBuilderScreen h2 { margin-top: 25px; }
        .deck-areas { display: flex; flex-direction: column; gap: 20px; }
        #cardLibrary, #selectedDeck { display: flex; flex-wrap: wrap; gap: 10px; padding: 15px; background-color: var(--tertiary-bg); border-radius: 10px; min-height: 100px; justify-content: center; }
        #selectedDeck { border: 3px dashed var(--accent-green); min-height: 95px; max-width: 600px; margin: 0 auto; } /* Width for 8 cards */
        .deck-slot-placeholder { width: 70px; height: 90px; background-color: rgba(0,0,0,0.2); border: 2px dashed var(--border-color); border-radius: 5px; box-sizing: border-box; }
        .card { /* Style for cards in library/deck */
            width: 70px; height: 90px; background-color: var(--card-bg); border: 2px solid var(--border-color); border-radius: 5px;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 5px; box-sizing: border-box;
            cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; position: relative; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .card:hover { transform: scale(1.05); border-color: var(--accent-yellow); box-shadow: 0 4px 10px rgba(0,0,0,0.4); }
        .card.disabled-card { opacity: 0.5; cursor: not-allowed; background-color: #555; }
        .card.disabled-card:hover { transform: none; border-color: var(--border-color); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .card-cost { position: absolute; top: 2px; left: 2px; background-color: var(--elixir-color); color: white; font-size: 0.7em; padding: 2px 4px; border-radius: 3px; font-weight: bold; border: 1px solid rgba(255,255,255,0.5); z-index: 1; }
        .card-name {
            font-size: 0.6em; text-align: center; margin-top: auto;
            color: var(--accent-yellow); text-shadow: 1px 1px 1px #000;
            word-break: break-word; line-height: 1.1; width: 100%; padding-bottom: 2px;
        }
        .card-icon {
            width: 45px; height: 55px; margin-top: 18px; margin-bottom: 2px;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .card-icon img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 3px; }
         .card-icon .fallback-text { font-size: 0.8em; color: var(--text-light); text-align: center; }

        #startBattleButton { display: block; margin: 25px auto 10px auto; padding: 12px 30px; font-size: 1.1em; background-image: var(--button-green-gradient); border: 2px solid rgba(0,0,0,0.5); border-top-color: rgba(255,255,255,0.2); border-left-color: rgba(255,255,255,0.2); box-shadow: 0 5px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #startBattleButton:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-2px); box-shadow: 0 7px 0px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }

        /* Battle Screen */
        .game-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; font-size: 0.9em; flex-wrap: wrap; gap: 10px; background-color: rgba(0,0,0,0.2); padding: 10px 15px; border-radius: 10px; border: 2px solid rgba(0,0,0,0.3); }
        #player-stats, #enemy-stats, #game-timer-container { text-align: center; padding: 8px 12px; background: linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(0,0,0,0.05)); border-radius: 8px; flex-grow: 1; flex-basis: 150px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }
        #player-stats { border-left: 5px solid var(--accent-blue); }
        #enemy-stats { border-right: 5px solid var(--accent-red); }
        #game-timer-container { border-bottom: 5px solid var(--accent-yellow); flex-basis: 100px; padding: 10px 5px; }
        #player-tower-hp, #enemy-tower-hp, #gameTimerDisplay { display: block; margin-top: 8px; font-weight: bold; text-shadow: 1px 1px 1px #000; }
        #player-tower-hp, #enemy-tower-hp { font-size: 1.0em; }
        #gameTimerDisplay { color: var(--accent-yellow); font-size: 1.4em; }
        /* Elixir Bar Styles */
        #player-elixir-display { background-color: transparent; padding: 0; display: block; margin-top: 10px; }
        .elixir-text { display: block; font-size: 1.0em; margin-bottom: 4px; color: var(--text-light); text-shadow: 1px 1px 1px #000; }
        .elixir-bar-container { width: 100%; max-width: 120px; height: 12px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden; margin: 0 auto; }
        .elixir-bar-fill { height: 100%; width: 0%; background-color: var(--elixir-color); border-radius: 3px; transition: width 0.2s ease-out; box-shadow: inset 0 0 3px rgba(255,255,255,0.3); }
        #gameCanvas { display: block; background-color: #aaa; background-image: var(--canvas-gradient); border: 4px solid var(--text-dark); margin: 0 auto 20px auto; max-width: 100%; height: auto; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); cursor: default; }
        #targetingIndicator { position: absolute; border: 3px dashed var(--accent-red); border-radius: 50%; background-color: rgba(231, 76, 60, 0.2); pointer-events: none; display: none; box-sizing: border-box; z-index: 5; }
        /* Added for placement validation */
        #placementIndicator { position: absolute; border: 3px solid green; border-radius: 5px; background-color: rgba(46, 204, 113, 0.2); pointer-events: none; display: none; box-sizing: border-box; z-index: 5; }
        #placementIndicator.invalid { border-color: red; background-color: rgba(231, 76, 60, 0.2); }

        #battleControls { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin-top: 15px; padding: 10px; background-color: var(--tertiary-bg); border-radius: 8px; min-height: 95px; border: 2px solid rgba(0,0,0,0.3); }
        button.deploy-button {
             width: 65px; height: 85px; background-color: var(--card-bg); border: 2px solid var(--border-color); border-radius: 5px;
             display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 5px; box-sizing: border-box;
             cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; position: relative; overflow: hidden;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 0.6em; text-shadow: none;
             color: var(--text-light); /* Default color for name, overridden by .card-name */
        }
        button.deploy-button:hover:not(:disabled) { transform: scale(1.05); border-color: var(--accent-yellow); box-shadow: 0 4px 10px rgba(0,0,0,0.4); filter: brightness(1.1); }
        button.deploy-button:active:not(:disabled) { transform: scale(1.02); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        button.deploy-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #555; transform: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3); border-color: var(--border-color); filter: grayscale(50%);}
        .deploy-button .card-cost {}
        .deploy-button .card-icon { width: 45px; height: 55px; margin-top: 18px; margin-bottom: 2px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .deploy-button .card-icon img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 3px; }
        .deploy-button .card-icon .fallback-text { font-size: 0.8em; color: var(--text-light); text-align: center; }
        .deploy-button .card-name { /* Inherits .card-name style */ margin-top: auto; }
        #messageBox { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(to bottom, rgba(44, 62, 80, 0.95), rgba(26, 42, 58, 0.95)); color: #fff; padding: 40px 50px; border-radius: 15px; font-size: 2.2em; text-align: center; display: none; z-index: 1000; border: 5px solid var(--accent-red); white-space: pre-line; box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 0 10px rgba(0,0,0,0.4); text-shadow: 2px 2px 3px #000; }

    </style>
</head>
<body>

    <div id="deckBuilderScreen" class="screen active">
        <h1>Build Your Deck</h1>
        <div class="deck-areas">
            <div>
                <h2>Selected Deck (Click to Remove) - Select 8</h2>
                <div id="selectedDeck"></div>
            </div>
            <div>
                <h2>Card Library (Click to Add)</h2>
                <div id="cardLibrary"></div>
            </div>
        </div>
        <button id="startBattleButton" disabled>Start Battle (Select 8 Cards)</button>
    </div>

    <div id="battleScreen" class="screen">
        <h1>Battle!</h1>
        <div class="game-info">
            <div id="player-stats"> Player <span id="player-tower-hp">King HP: 1000</span>
                 <span id="player-elixir-display">
                     <span class="elixir-text">Elixir: 3 / 10</span>
                     <div class="elixir-bar-container"> <div class="elixir-bar-fill"></div> </div>
                 </span>
            </div>
            <div id="game-timer-container"> Time Left <span id="gameTimerDisplay">3:00</span> </div>
            <div id="enemy-stats"> Enemy <span id="enemy-tower-hp">King HP: 1000</span> </div>
        </div>
        <div style="position: relative; max-width: 800px; margin: 0 auto 15px auto;">
             <canvas id="gameCanvas" width="800" height="250"></canvas>
             <div id="targetingIndicator"></div>
             <div id="placementIndicator"></div> </div>
        <div id="battleControls"></div>
        <button id="resetButton">End Battle & Build Deck</button>
    </div>

    <div id="messageBox">You Win!</div>


    <script>
        // --- DOM Elements ---
        const deckBuilderScreen = document.getElementById('deckBuilderScreen');
        const battleScreen = document.getElementById('battleScreen');
        const cardLibraryContainer = document.getElementById('cardLibrary');
        const selectedDeckContainer = document.getElementById('selectedDeck');
        const startBattleButton = document.getElementById('startBattleButton');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const playerElixirDisplaySpan = document.querySelector('#player-elixir-display .elixir-text');
        const playerElixirBarFill = document.querySelector('#player-elixir-display .elixir-bar-fill');
        const playerTowerHpDisplay = document.getElementById('player-tower-hp');
        const enemyTowerHpDisplay = document.getElementById('enemy-tower-hp');
        const battleControlsContainer = document.getElementById('battleControls');
        const messageBox = document.getElementById('messageBox');
        const resetButton = document.getElementById('resetButton');
        const gameTimerDisplay = document.getElementById('gameTimerDisplay');
        const targetingIndicator = document.getElementById('targetingIndicator');
        const placementIndicator = document.getElementById('placementIndicator'); // Added

        // --- Game Configuration ---
        const KING_TOWER_HP = 1000; const PRINCESS_TOWER_HP = 600; const TOWER_RANGE = 150;
        const KING_TOWER_DAMAGE = 10; const PRINCESS_TOWER_DAMAGE = 12; const TOWER_ATTACK_SPEED = 1000;
        const KING_TOWER_WIDTH = 60; const KING_TOWER_HEIGHT = 100; const PRINCESS_TOWER_WIDTH = 45; const PRINCESS_TOWER_HEIGHT = 75;
        const MAX_ELIXIR = 10; const ELIXIR_REGEN_RATE = 1; const ELIXIR_REGEN_INTERVAL = 1000; // 1 elixir per second
        const BATTLE_DURATION_SECONDS = 180; const TIEBREAKER_HP_DRAIN_RATE = 15; const TIEBREAKER_DRAIN_INTERVAL = 500;
        const DECK_SIZE = 8;
        const PLACEMENT_TILE_SIZE = 30; // For building placement checks
        const PLAYER_SIDE_X_LIMIT = 400; // Midpoint of 800 width canvas
        const ATTACK_ANIMATION_DURATION = 150; // ms for attack visual
        const DEATH_ANIMATION_DURATION = 300; // ms for death fade out
        const WALK_ANIMATION_INTERVAL = 15; // Toggle walk frame every N game loop frames


        // --- Card Library with imageUrl ---
        const PLACEHOLDER_URL_BASE = "https://placehold.co/60x80/4a6883/ecf0f1?text=";
        const FULL_CARD_LIBRARY = [
            // --- Existing Units ---
            { id: 'melee', name: 'Mini Pekka', type: 'unit', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000018.webp`, stats: { hp: 100, damage: 15, speed: 1.5, range: 25, attackSpeed: 800, size: 20, color: '#3498db', shape: 'square', maxHp: 100, targets: ['ground'] } }, // Added targets
            { id: 'ranged', name: 'Archer', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000001.webp`, stats: { hp: 60, damage: 10, speed: 1.2, range: 100, attackSpeed: 1000, size: 18, color: '#2ecc71', shape: 'circle', maxHp: 60, targets: ['air', 'ground'] } }, // Added targets
            { id: 'tank', name: 'Giant', type: 'unit', cost: 5, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000003.webp`, stats: { hp: 250, damage: 10, speed: 0.8, range: 25, attackSpeed: 1200, size: 25, color: '#7f8c8d', shape: 'square', maxHp: 250, targets: ['ground'], targetPreference: 'building' } }, // Added targets, preference
            { id: 'assassin', name: 'Bandit', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000046.webp`, stats: { hp: 80, damage: 35, speed: 2.0, range: 25, attackSpeed: 900, size: 18, color: '#8e44ad', shape: 'diamond', maxHp: 80, targets: ['ground'] } }, // Added targets
            { id: 'skeletons', name: 'Skeletons', type: 'unit', cost: 1, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000010.webp`, stats: { spawnCount: 3, unitStats: { hp: 15, damage: 5, speed: 1.8, range: 25, attackSpeed: 1000, size: 15, color: '#ecf0f1', shape: 'circle', maxHp: 15, targets: ['ground'] } } }, // Added targets
            { id: 'knight', name: 'Knight', type: 'unit', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000000.webp`, stats: { hp: 120, damage: 18, speed: 1.5, range: 25, attackSpeed: 900, size: 20, color: '#bdc3c7', shape: 'square', maxHp: 120, targets: ['ground'] } }, // Added targets
            { id: 'bats', name: 'Bats', type: 'unit', cost: 2, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000049.webp`, stats: { spawnCount: 3, unitStats: { hp: 15, damage: 6, speed: 2.2, range: 25, attackSpeed: 900, size: 15, color: '#512E5F', shape: 'diamond', maxHp: 15, isAir: true, targets: ['air', 'ground'] } } }, // Added targets

            // --- Existing Spells ---
            { id: 'fireball', name: 'Fireball', type: 'spell', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/28000000.webp`, stats: { damage: 100, radius: 50, delay: 500, targets: ['air', 'ground'] } }, // Added targets flag

            // --- *** NEWLY IMPLEMENTED CARDS *** ---
            { id: 'log', name: 'The Log', type: 'spell', cost: 2, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/28000011.webp`, stats: { damage: 40, width: 40, speed: 4, travelDistance: 350, pushbackStrength: 5, pushbackDuration: 150, targets: ['ground'] } },
            { id: 'cannon', name: 'Cannon', type: 'building', cost: 3, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/27000000.webp`, stats: { hp: 150, damage: 25, range: 130, attackSpeed: 800, lifetime: 30000, size: 40, color: '#95a5a6', maxHp: 150, targets: ['ground'] } },
            { id: 'hogrider', name: 'Hog Rider', type: 'unit', cost: 4, implemented: true, imageUrl: `https://cdn.statsroyale.com/v6/cards/full_b/26000021.webp`, stats: { hp: 200, damage: 40, speed: 2.0, range: 25, attackSpeed: 1000, size: 22, color: '#f39c12', shape: 'square', maxHp: 200, targetPreference: 'building', targets: ['ground'] } }, // Added targets

            // --- Unimplemented Cards ---
            { id: 'arrows', name: 'Arrows', type: 'spell', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ARR` },
            { id: 'zap_evo', name: 'Zap Evo', type: 'spell', cost: 2, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ZAP` },
            { id: 'mortar_evo', name: 'Mortar Evo', type: 'building', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}MOR` },
            { id: 'princess', name: 'Princess', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}PRI` },
            { id: 'pekka', name: 'P.E.K.K.A', type: 'unit', cost: 7, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}PEK` },
            { id: 'guards', name: 'Guards', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GUA` },
            { id: 'icespirit', name: 'Ice Spirit', type: 'unit', cost: 1, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}ICE` },
            { id: 'goblingang', name: 'Goblin Gang', type: 'unit', cost: 3, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GG` },
            { id: 'babydragon', name: 'Baby Dragon', type: 'unit', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}BD` },
            { id: 'megaknight', name: 'Mega Knight', type: 'unit', cost: 7, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}MK` },
            { id: 'poison', name: 'Poison', type: 'spell', cost: 4, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}POI` },
            { id: 'golem', name: 'Golem', type: 'unit', cost: 8, implemented: false, imageUrl: `${PLACEHOLDER_URL_BASE}GOL` },
        ];
        function getCardById(id) { return FULL_CARD_LIBRARY.find(card => card.id === id); }

        const ENEMY_COLORS = {
             melee: '#c0392b', ranged: '#f1c40f', tank: '#566573', assassin: '#d2b4de',
             skeletons: '#bdc3c7', knight: '#95a5a6', bats: '#9B59B6',
             hogrider: '#e67e22', // Enemy Hog color
             cannon: '#7f8c8d', // Enemy Cannon color
        }
        const AI_DEPLOY_INTERVAL = 2500; // AI thinks slightly faster
        const AI_STARTING_ELIXIR = 5;
        // Defines the pool of cards the AI can choose from. Assumes these are implemented.
        const AI_DECK = ['knight', 'archer', 'giant', 'skeletons', 'bats', 'hogrider', 'cannon', 'fireball'];
        // Simple counter map: key is unit type AI wants to counter, value is a preferred counter card ID
        const AI_COUNTERS = {
            'hogrider': 'cannon', // Cannon counters Hog
            'giant': 'cannon',    // Cannon counters Giant
            'tank': 'cannon',     // Cannon generally good vs tanks
            'knight': 'skeletons',// Skeletons distract Knight
            'melee': 'skeletons', // Skeletons distract Mini Pekka
            'ranged': 'knight',   // Knight can tank archers
            'default': 'knight'   // Default counter if specific isn't found
        };

        // --- Game State ---
        let selectedDeck = [];
        let playerElixir = 3;
        let playerUnits = [];
        let enemyUnits = [];
        let playerBuildings = [];
        let enemyBuildings = [];
        let projectiles = [];
        let logProjectiles = [];
        let playerTowers = [];
        let enemyTowers = [];
        let attackEffects = [];
        let elixirIntervalId = null;
        let aiIntervalId = null;
        let animationFrameId = null;
        let gameOver = false;
        let aiElixir = 5;
        let gameTimerIntervalId = null;
        let gameTimeRemaining = BATTLE_DURATION_SECONDS;
        let isTiebreakerActive = false;
        let tiebreakerIntervalId = null;
        let tiebreakerEffectCounter = 0;
        let isTargetingSpell = false;
        let currentSpellType = null;
        let isPlacingBuilding = false;
        let currentBuildingType = null;
        let gameFrameCounter = 0; // Added for walk animation timing

        // --- Tower Initialization ---
        function createTowers(isPlayer) {
            const canvasWidth = canvas?.width || 800; const canvasHeight = canvas?.height || 250;
            const kingY = canvasHeight / 2; const princessYOffset = 60;
            const kingX = isPlayer ? 80 : canvasWidth - 80 - KING_TOWER_WIDTH;
            const princessXOffset = KING_TOWER_WIDTH / 2 + PRINCESS_TOWER_WIDTH / 2 + 15;
            // Add attack state properties
            const kingTower = { id: isPlayer ? 'player_king' : 'enemy_king', x: kingX, y: kingY, hp: KING_TOWER_HP, maxHp: KING_TOWER_HP, width: KING_TOWER_WIDTH, height: KING_TOWER_HEIGHT, range: TOWER_RANGE, damage: KING_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: true, color: isPlayer ? '#3498db' : '#e74c3c', targets: ['air', 'ground'], isAttacking: false, attackAnimationEndTime: 0 };
            const princessLeft = { id: isPlayer ? 'player_pleft' : 'enemy_pleft', x: kingX + (isPlayer ? princessXOffset : -princessXOffset), y: kingY - princessYOffset, hp: PRINCESS_TOWER_HP, maxHp: PRINCESS_TOWER_HP, width: PRINCESS_TOWER_WIDTH, height: PRINCESS_TOWER_HEIGHT, range: TOWER_RANGE, damage: PRINCESS_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: false, color: isPlayer ? '#5dade2' : '#ec7063', targets: ['air', 'ground'], isAttacking: false, attackAnimationEndTime: 0 };
            const princessRight = { id: isPlayer ? 'player_pright' : 'enemy_pright', x: kingX + (isPlayer ? princessXOffset : -princessXOffset), y: kingY + princessYOffset, hp: PRINCESS_TOWER_HP, maxHp: PRINCESS_TOWER_HP, width: PRINCESS_TOWER_WIDTH, height: PRINCESS_TOWER_HEIGHT, range: TOWER_RANGE, damage: PRINCESS_TOWER_DAMAGE, attackSpeed: TOWER_ATTACK_SPEED, lastAttackTime: 0, isTower: true, isKingTower: false, color: isPlayer ? '#5dade2' : '#ec7063', targets: ['air', 'ground'], isAttacking: false, attackAnimationEndTime: 0 };
            return [princessLeft, kingTower, princessRight];
        }

        // --- Utilities ---
        function distance(x1, y1, x2, y2) { return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); }
        function isGroundUnit(unit) { return !unit?.stats?.isAir; }

        // --- Drawing ---
        // --- *** MODIFIED: drawTower includes attack animation *** ---
        function drawTower(tower) {
             if (!ctx || !tower) return;
             if (tower.hp > 0) {
                 const heightModifier = tower.isKingTower ? 1 : 0.8; const widthModifier = tower.isKingTower ? 1 : 0.9;
                 const actualHeight = tower.height * heightModifier; const actualWidth = tower.width * widthModifier;
                 const healthBarY = tower.y - actualHeight / 2 - 15; const healthBarHeight = 10;

                 // Base tower
                 ctx.fillStyle = tower.color;
                 ctx.fillRect(tower.x, tower.y - actualHeight / 2, actualWidth, actualHeight);

                 // Decorative top
                 ctx.fillStyle = lightenColor(tower.color, 20);
                 if (tower.isKingTower) { ctx.fillRect(tower.x + actualWidth * 0.1, tower.y - actualHeight / 2, actualWidth * 0.8, 10); }
                  else { ctx.beginPath(); ctx.moveTo(tower.x, tower.y - actualHeight / 2); ctx.lineTo(tower.x + actualWidth / 2, tower.y - actualHeight / 2 - 10); ctx.lineTo(tower.x + actualWidth, tower.y - actualHeight / 2); ctx.closePath(); ctx.fill(); }

                 // --- Attack Animation (Flash) ---
                 if (tower.isAttacking) {
                     ctx.fillStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow flash
                     ctx.beginPath();
                     ctx.arc(tower.x + actualWidth / 2, tower.y - actualHeight / 2, 5, 0, Math.PI * 2); // Flash at top center
                     ctx.fill();
                 }
                 // --- End Attack Animation ---

                 // Health Bar & Text
                 drawHealthBar(tower.x, healthBarY, actualWidth, healthBarHeight, tower.hp, tower.maxHp, true, tower.color === (playerTowers[1]?.color || '#3498db'));
                 const hpText = Math.max(0, Math.round(tower.hp)); const textX = tower.x + actualWidth / 2; const textY = healthBarY - 4;
                 ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 2;
                 ctx.font = tower.isKingTower ? '10px "Press Start 2P"' : '9px "Press Start 2P"';
                 ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                 ctx.strokeText(hpText, textX, textY); ctx.fillText(hpText, textX, textY);
             } else if (!tower.isKingTower) { drawRubble(tower.x, tower.y, tower.width * 0.9); }
        }
        function drawRubble(x, y, width) { /* ... (no changes) ... */
            if (!ctx) return; const rubbleColor = '#6c757d'; const pieceSize = width / 4;
            ctx.fillStyle = rubbleColor; const baseY = y + PRINCESS_TOWER_HEIGHT * 0.8 / 2 - pieceSize;
            ctx.fillRect(x + width * 0.1, baseY, pieceSize, pieceSize);
            ctx.fillRect(x + width * 0.6, baseY - pieceSize * 0.5, pieceSize * 1.2, pieceSize * 0.8);
            ctx.fillRect(x + width * 0.3, baseY - pieceSize, pieceSize * 0.8, pieceSize * 1.2);
            ctx.fillStyle = lightenColor(rubbleColor, -20);
            ctx.fillRect(x + width * 0.5, baseY - pieceSize * 0.5, pieceSize, pieceSize * 0.7);
        }

        // --- *** MODIFIED: drawUnit uses specific drawing logic per type *** ---
        function drawUnit(unit) {
            if (!ctx || !unit || !unit.stats || typeof unit.maxHp === 'undefined') return;

            const size = unit.stats.size || 15;
            const halfSize = size / 2;
            const x = unit.x;
            const y = unit.y;
            const color = unit.color;
            const currentTime = Date.now();

            ctx.save(); // Save context

            // --- Handle Death Animation (Fade Out) ---
            let alpha = 1.0;
            if (unit.isDying) {
                const timeRemaining = unit.deathAnimationEndTime - currentTime;
                if (timeRemaining <= 0) {
                    alpha = 0; // Completely faded - will be removed by gameLoop cleanup
                } else {
                    alpha = Math.max(0, timeRemaining / DEATH_ANIMATION_DURATION); // Calculate fade alpha
                }
                ctx.globalAlpha = alpha;
            }
            // --- End Death Animation ---

            if (alpha > 0) { // Only draw if not fully faded
                ctx.translate(x, y); // Move origin to unit center

                // Determine if walking animation should apply (simple leg shift example)
                // Only apply walk offset if unit is actually moving AND not attacking (prioritize attack visual)
                const walkOffset = (unit.isMoving && !unit.isAttacking && unit.walkFrame === 1) ? 2 : 0;

                // --- Specific Drawing Logic per Unit Type ---
                switch (unit.type) {
                    case 'knight':
                        ctx.fillStyle = color; ctx.fillRect(-halfSize * 0.6 + walkOffset, -halfSize * 0.8, size * 1.2, size * 1.6); // Body shifts slightly
                        ctx.fillStyle = lightenColor(color, 20); ctx.beginPath(); ctx.arc(0 + walkOffset, -halfSize * 0.9, halfSize * 0.5, 0, Math.PI * 2); ctx.fill(); // Head shifts
                        ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(halfSize * 0.5 + walkOffset, -halfSize * 0.2);
                        if (unit.isAttacking) { ctx.lineTo(halfSize * 1.5 + walkOffset, -halfSize * 0.8); } // Attacking pose
                        else { ctx.lineTo(halfSize * 1.2 + walkOffset, halfSize * 0.8); } // Idle/Walk pose
                        ctx.stroke(); // Sword
                        break;
                    case 'archer':
                        ctx.fillStyle = color; ctx.fillRect(-halfSize * 0.5 + walkOffset, -halfSize * 0.7, size, size * 1.4); // Body
                        ctx.fillStyle = lightenColor(color, 30); ctx.beginPath(); ctx.arc(0 + walkOffset, -halfSize * 0.8, halfSize * 0.4, 0, Math.PI * 2); ctx.fill(); // Head
                        ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(halfSize * 0.3 + walkOffset, 0, halfSize * 0.8, Math.PI * 0.6, Math.PI * 1.4); ctx.stroke(); // Bow
                        if (unit.isAttacking) { ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.moveTo(halfSize * 0.5 + walkOffset, 0); ctx.lineTo(halfSize * 1.5 + walkOffset, 0); ctx.lineTo(halfSize * 1.3 + walkOffset, -2); ctx.moveTo(halfSize * 1.5 + walkOffset, 0); ctx.lineTo(halfSize * 1.3 + walkOffset, 2); ctx.fill(); } // Arrow flash
                        break;
                    case 'skeletons':
                        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0 + walkOffset, -halfSize * 0.5, halfSize * 0.4, 0, Math.PI * 2); ctx.fill(); // Head
                        ctx.fillRect(-1 + walkOffset, -halfSize * 0.2, 2, size * 0.8); // Body
                        if (unit.isAttacking) { ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fillRect(-1 + walkOffset, -halfSize * 0.2, 2, size * 0.8); } // Red flash on body
                        break;
                    case 'bats': // Air units don't have walk animation here
                         ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, -halfSize * 0.6); ctx.lineTo(halfSize * 0.5, 0); ctx.lineTo(0, halfSize * 0.6); ctx.lineTo(-halfSize * 0.5, 0); ctx.closePath(); ctx.fill(); // Body
                         const wingYOffset = (unit.walkFrame === 1) ? -halfSize * 0.1 : 0; // Simple flap based on frame
                         ctx.beginPath(); ctx.moveTo(-halfSize * 0.4, -halfSize * 0.1); ctx.lineTo(-halfSize * 1.2, -halfSize * 0.5 + wingYOffset); ctx.lineTo(-halfSize * 1.0, halfSize * 0.2); ctx.closePath(); ctx.fill(); // Left Wing
                         ctx.beginPath(); ctx.moveTo(halfSize * 0.4, -halfSize * 0.1); ctx.lineTo(halfSize * 1.2, -halfSize * 0.5 + wingYOffset); ctx.lineTo(halfSize * 1.0, halfSize * 0.2); ctx.closePath(); ctx.fill(); // Right Wing
                         if (unit.isAttacking) { ctx.fillStyle = 'rgba(255, 255, 0, 0.6)'; ctx.beginPath(); ctx.arc(0, 0, halfSize * 0.5, 0, Math.PI * 2); ctx.fill(); } // Attack flash
                         break;
                    case 'hogrider':
                        ctx.fillStyle = '#A9A9A9'; ctx.fillRect(-halfSize * 0.8 + walkOffset, 0, size * 1.6, size * 0.8); // Hog body
                        ctx.fillStyle = color; ctx.fillRect(-halfSize * 0.4 + walkOffset, -halfSize * 1.2, size * 0.8, size * 1.2); // Rider body
                        ctx.fillStyle = lightenColor(color, 20); ctx.beginPath(); ctx.arc(0 + walkOffset, -halfSize * 1.3, halfSize * 0.3, 0, Math.PI * 2); ctx.fill(); // Rider head
                        ctx.strokeStyle = '#696969'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(halfSize * 0.3 + walkOffset, -halfSize * 0.5);
                        if (unit.isAttacking) { ctx.lineTo(halfSize * 1.0 + walkOffset, halfSize * 1.0); ctx.fillStyle = '#808080'; ctx.fillRect(halfSize*0.8 + walkOffset, halfSize*0.8, halfSize*0.5, halfSize*0.5); } // Attack pose
                        else { ctx.lineTo(halfSize * 0.8 + walkOffset, -halfSize * 1.0); ctx.fillStyle = '#808080'; ctx.fillRect(halfSize*0.6 + walkOffset, -halfSize*1.2, halfSize*0.5, halfSize*0.5); } // Idle/Walk pose
                        ctx.stroke();
                        break;
                    case 'melee': // Mini Pekka
                        ctx.fillStyle = color; ctx.fillRect(-halfSize * 0.7 + walkOffset, -halfSize * 0.9, size * 1.4, size * 1.8); // Body
                        ctx.fillStyle = lightenColor(color, 30); ctx.beginPath(); ctx.moveTo(-halfSize*0.3 + walkOffset, -halfSize*0.9); ctx.lineTo(-halfSize*0.5 + walkOffset, -halfSize*1.3); ctx.lineTo(-halfSize*0.1 + walkOffset, -halfSize*1.1); ctx.fill(); // Horn L
                        ctx.beginPath(); ctx.moveTo(halfSize*0.3 + walkOffset, -halfSize*0.9); ctx.lineTo(halfSize*0.5 + walkOffset, -halfSize*1.3); ctx.lineTo(halfSize*0.1 + walkOffset, -halfSize*1.1); ctx.fill(); // Horn R
                        ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(halfSize * 0.6 + walkOffset, -halfSize * 0.2);
                        if (unit.isAttacking) { ctx.lineTo(halfSize * 1.6 + walkOffset, -halfSize * 0.2); } else { ctx.lineTo(halfSize * 1.3 + walkOffset, halfSize * 0.9); } ctx.stroke(); // Sword
                        break;
                    case 'tank': // Giant
                        ctx.fillStyle = color; ctx.fillRect(-halfSize + walkOffset, -halfSize, size, size); // Body
                        ctx.fillStyle = lightenColor(color, 10); const fistOffset = unit.isAttacking ? halfSize * 0.6 : halfSize * 0.4;
                        ctx.beginPath(); ctx.arc(fistOffset + walkOffset, halfSize * 0.3, halfSize * 0.3, 0, Math.PI * 2); ctx.fill(); // Fist R
                        ctx.beginPath(); ctx.arc(fistOffset + walkOffset, -halfSize * 0.3, halfSize * 0.3, 0, Math.PI * 2); ctx.fill(); // Fist L
                        break;
                    case 'assassin': // Bandit
                         ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0 + walkOffset, -halfSize); ctx.lineTo(halfSize + walkOffset, 0); ctx.lineTo(0 + walkOffset, halfSize); ctx.lineTo(-halfSize + walkOffset, 0); ctx.closePath(); ctx.fill(); // Body
                         ctx.fillStyle = lightenColor(color, 30); ctx.fillRect(-halfSize*0.3 + walkOffset, -halfSize*0.4, halfSize*0.6, halfSize*0.3); // Mask
                         if (unit.isAttacking) { ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(halfSize * 0.8 + walkOffset, 0, halfSize * 0.4, 0, Math.PI * 2); ctx.fill(); } // Attack flash
                         break;
                    default: // Fallback
                        ctx.fillStyle = color; ctx.fillRect(-halfSize + walkOffset, -halfSize, size, size);
                        break;
                }
            }

            ctx.restore(); // Restore context (including alpha)

            // Draw health bar only if unit is not dying or just started dying
            if (!unit.isDying || alpha > 0.5) {
                 drawHealthBar(x - halfSize, y - size - 5, size, 5, unit.hp, unit.maxHp);
            }
        }

        // --- *** MODIFIED: drawBuilding includes attack animation *** ---
        function drawBuilding(building) {
            if (!ctx || !building || !building.stats) return;
            const size = building.stats.size || 40;
            const halfSize = size / 2;
            const healthBarY = building.y - halfSize - 15; // Position health bar above
            const healthBarHeight = 8;

            // Base (simple square)
            ctx.fillStyle = building.color;
            ctx.fillRect(building.x - halfSize, building.y - halfSize, size, size);

            // Cannon Barrel
            ctx.fillStyle = lightenColor(building.color, -20);
            const barrelWidth = size * 0.2;
            const barrelLength = size * 0.4;
            const barrelX = building.x - barrelWidth / 2;
            // Point barrel slightly upwards
            const barrelY = building.y - halfSize - barrelLength + 5; // Adjusted Y
            ctx.fillRect(barrelX, barrelY, barrelWidth, barrelLength);

             // --- Attack Animation (Flash) ---
             if (building.isAttacking) {
                 ctx.fillStyle = 'rgba(255, 255, 0, 0.8)'; // Yellow flash
                 ctx.beginPath();
                 ctx.arc(building.x, barrelY, 5, 0, Math.PI * 2); // Flash at barrel tip
                 ctx.fill();
             }
             // --- End Attack Animation ---

            // Draw health bar
            drawHealthBar(building.x - halfSize, healthBarY, size, healthBarHeight, building.hp, building.maxHp);
        }

        // --- *** MODIFIED: drawLogProjectile with more texture *** ---
        function drawLogProjectile(log) {
            if (!ctx || !log) return;
            const width = log.stats.width;
            const length = 60; // Visual length of the log
            const angle = log.direction === 1 ? 0 : Math.PI; // Rotation based on direction

            ctx.save(); // Save context state
            ctx.translate(log.x, log.y); // Move origin to log center

            // Draw log body (brown rectangle)
            ctx.fillStyle = log.color || '#8B4513'; // Brown
            ctx.fillRect(-length / 2, -width / 2, length, width);

            // Draw "bark" texture lines
            ctx.strokeStyle = lightenColor(log.color || '#8B4513', -30); // Darker brown lines
            ctx.lineWidth = 1;
            for (let i = -length / 2 + 5; i < length / 2; i += 8) {
                ctx.beginPath();
                ctx.moveTo(i, -width / 2);
                ctx.lineTo(i + Math.random()*4-2, width / 2); // Jagged lines
                ctx.stroke();
            }

             // Draw "spikes" or texture
             ctx.fillStyle = lightenColor(log.color || '#8B4513', -20);
             for (let i = 0; i < 3; i++) {
                 ctx.fillRect(-length / 2 + i * (length/3) + 5, -width/2 - 2, length/6, 4); // Top spikes
                 ctx.fillRect(-length / 2 + i * (length/3) + 10, width/2 -2, length/6, 4); // Bottom spikes
             }


            ctx.restore(); // Restore context state
        }

        function drawHealthBar(x, y, width, height, currentHp, maxHp, isTowerBar = false, isPlayerTower = false) { /* ... (no changes) ... */
             if (!ctx) return; const validMaxHp = Math.max(1, maxHp); const hpPercent = Math.max(0, currentHp) / validMaxHp;
             ctx.fillStyle = isTowerBar ? '#7f8c8d' : '#e74c3c'; ctx.fillRect(x, y, width, height);
             ctx.fillStyle = isTowerBar ? (isPlayerTower ? '#3498db' : '#e74c3c') : '#2ecc71';
             ctx.fillRect(x, y, width * hpPercent, height);
             ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 1; ctx.strokeRect(x, y, width, height);
         }
        function drawProjectile(p) { /* ... (no changes) ... */ if (!ctx) return; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
        function lightenColor(hex, percent) { /* ... (no changes) ... */
            hex = hex.replace(/^\s*#|\s*$/g, ''); if(hex.length == 3){ hex = hex.replace(/(.)/g, '$1$1'); }
            var bigint = parseInt(hex, 16); var r = (bigint >> 16) & 255; var g = (bigint >> 8) & 255; var b = bigint & 255;
            r = Math.min(255, r + (255 * percent / 100)); g = Math.min(255, g + (255 * percent / 100)); b = Math.min(255, b + (255 * percent / 100));
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        function drawAttackEffects() { /* ... (no changes) ... */
            if (!ctx) return;
            const currentTime = Date.now();
            attackEffects.forEach(effect => {
                const elapsed = currentTime - effect.startTime;
                const progress = Math.min(1, elapsed / effect.duration);
                const alpha = 1 - progress;
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                if (effect.type === 'slash') {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.9})`; ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(0, 255, 255, 0.7)'; ctx.shadowBlur = 5;
                    ctx.beginPath(); ctx.moveTo(effect.x1, effect.y1); ctx.lineTo(effect.x2, effect.y2); ctx.stroke();
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                } else if (effect.type === 'flash') {
                    ctx.fillStyle = `rgba(255, 255, 150, ${alpha * 0.7})`; ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius * (1 + progress * 0.5), 0, Math.PI * 2); ctx.fill();
                } else if (effect.type === 'explosion') {
                    const currentRadius = effect.radius * progress; ctx.fillStyle = effect.color || 'rgba(255, 100, 0, 0.8)';
                    ctx.beginPath(); ctx.arc(effect.x, effect.y, currentRadius, 0, Math.PI * 2); ctx.fill();
                    if (progress < 0.5) {
                        ctx.fillStyle = `rgba(255, 255, 150, ${alpha * 0.5})`; ctx.beginPath();
                        ctx.arc(effect.x, effect.y, currentRadius * 0.5, 0, Math.PI * 2); ctx.fill();
                    }
                }
                ctx.globalAlpha = 1.0; // Reset global alpha
            });
        }


        // --- Deck Building ---
        function renderCardLibrary() { /* ... (no changes) ... */
            if (!cardLibraryContainer) return;
            cardLibraryContainer.innerHTML = '';
            FULL_CARD_LIBRARY.forEach(card => {
                const cardElement = createCardElement(card, 'library');
                cardLibraryContainer.appendChild(cardElement);
            });
        }
        function renderSelectedDeck() { /* ... (no changes) ... */
            if (!selectedDeckContainer) return;
            selectedDeckContainer.innerHTML = '';
            selectedDeck.forEach((cardId, index) => {
                const card = getCardById(cardId);
                if (card) {
                    const cardElement = createCardElement(card, 'deck', index);
                    selectedDeckContainer.appendChild(cardElement);
                }
            });
            const placeholdersNeeded = DECK_SIZE - selectedDeck.length;
            for (let i = 0; i < placeholdersNeeded; i++) {
                const deckSlot = document.createElement('div');
                deckSlot.classList.add('deck-slot-placeholder');
                selectedDeckContainer.appendChild(deckSlot);
            }
            startBattleButton.disabled = selectedDeck.length !== DECK_SIZE;
            startBattleButton.textContent = selectedDeck.length === DECK_SIZE ? "Start Battle!" : `Select ${DECK_SIZE - selectedDeck.length} More Cards`;
        }
        function createCardElement(card, location, index = -1) { /* ... (no changes) ... */
            const cardElement = document.createElement('div');
            cardElement.classList.add('card');
            cardElement.dataset.id = card.id;
            cardElement.dataset.type = card.type; // Ensure type is set
            const costElement = document.createElement('div');
            costElement.classList.add('card-cost');
            costElement.textContent = card.cost;
            cardElement.appendChild(costElement);
            const iconContainer = document.createElement('div');
            iconContainer.classList.add('card-icon');
            if (card.imageUrl) {
                const imgElement = document.createElement('img');
                imgElement.src = card.imageUrl; imgElement.alt = card.name;
                imgElement.onerror = function() { this.onerror = null; this.style.display = 'none'; const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); };
                iconContainer.appendChild(imgElement);
            } else { const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); }
            cardElement.appendChild(iconContainer);
            const nameElement = document.createElement('div');
            nameElement.classList.add('card-name');
            nameElement.textContent = card.name;
            cardElement.appendChild(nameElement);
             if (!card.implemented) { cardElement.classList.add('disabled-card'); nameElement.textContent += " (N/A)"; }
            if (location === 'library' && card.implemented) { cardElement.addEventListener('click', () => { if (!selectedDeck.includes(card.id)) { addCardToDeck(card.id); } else { console.log(`${card.name} is already in the deck.`); } }); }
             else if (location === 'deck') { cardElement.addEventListener('click', () => removeCardFromDeck(index)); }
            return cardElement;
        }
        function addCardToDeck(cardId) { /* ... (no changes) ... */
            if (selectedDeck.length < DECK_SIZE) { selectedDeck.push(cardId); renderSelectedDeck(); }
             else { console.log("Deck is full!"); }
        }
        function removeCardFromDeck(index) { /* ... (no changes) ... */
             if (index >= 0 && index < selectedDeck.length) { selectedDeck.splice(index, 1); renderSelectedDeck(); }
              else { console.error("Invalid index for card removal:", index, selectedDeck); }
        }

        // --- Battle Logic ---
        function populateBattleControls() { /* ... (no changes) ... */
            if (!battleControlsContainer) return;
            battleControlsContainer.innerHTML = '';
            selectedDeck.forEach(cardId => {
                const card = getCardById(cardId);
                if (card) {
                    const button = document.createElement('button');
                    button.classList.add('deploy-button');
                    button.dataset.id = card.id;
                    button.dataset.type = card.type; // Set type for listener
                    button.dataset.cost = card.cost;
                    button.disabled = !card.implemented || playerElixir < card.cost;
                    const iconContainer = document.createElement('div'); iconContainer.classList.add('card-icon');
                    if (card.imageUrl) { /* ... image loading ... */
                        const imgElement = document.createElement('img'); imgElement.src = card.imageUrl; imgElement.alt = card.name;
                        imgElement.onerror = function() { this.onerror = null; this.style.display = 'none'; const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback); };
                        iconContainer.appendChild(imgElement);
                    } else { /* ... fallback text ... */
                        const fallback = document.createElement('span'); fallback.classList.add('fallback-text'); const nameParts = card.name.split(' '); let initials = nameParts[0] ? nameParts[0][0] : '?'; if (nameParts.length > 1 && nameParts[1]) initials += nameParts[1][0]; fallback.textContent = initials.toUpperCase(); iconContainer.appendChild(fallback);
                    }
                    button.innerHTML = ` <div class="card-cost">${card.cost}</div> ${iconContainer.outerHTML} <div class="card-name">${card.name}${!card.implemented ? ' (N/A)' : ''}</div> `;
                    if(card.id === 'knight') button.style.backgroundImage = 'var(--button-silver-gradient)';
                    else if(card.id === 'bats') button.style.backgroundImage = 'var(--button-darkpurple-gradient)';
                    else if(card.id === 'skeletons') { button.style.backgroundImage = 'var(--button-white-gradient)'; button.style.color = '#333'; button.style.textShadow = 'none';}
                    else if(card.id === 'fireball' || card.id === 'hogrider') button.style.backgroundImage = 'var(--button-orange-gradient)'; // Hog uses orange too
                    else if(card.id === 'log') button.style.backgroundImage = 'var(--button-brown-gradient)';
                    else if(card.id === 'cannon') button.style.backgroundImage = 'var(--button-gray-gradient)';
                    battleControlsContainer.appendChild(button);
                }
            });
             // setupDeployButtonListeners called by override
        }
        function handleDeployAction(cardId, clickX, clickY) { /* ... (no changes) ... */
             const card = getCardById(cardId);
             if (!card || !card.implemented) { console.error("handleDeployAction called with invalid/unimplemented card:", cardId); return; };
             if (card.type === 'unit') { deployUnit(card.id, true); }
             else if (card.type === 'spell') {
                 if (card.id === 'log') { executeSpellEffect(card.id, clickX, clickY); }
                 else { startSpellTargeting(card.id); }
             } else if (card.type === 'building') { startBuildingPlacement(card.id); }
        }

        // --- Spell Logic ---
        function startSpellTargeting(spellId) { /* ... (no changes) ... */
             const spellCard = getCardById(spellId);
             if (isTargetingSpell || isPlacingBuilding || !canvas || !spellCard || spellCard.type !== 'spell' || spellId === 'log' || !spellCard.stats.radius) return;
             console.log(`Targeting ${spellId}...`);
             isTargetingSpell = true; currentSpellType = spellId; canvas.style.cursor = 'crosshair';
             updateBattleButtons();
             if (targetingIndicator && spellCard.stats.radius) {
                 const radius = spellCard.stats.radius;
                 targetingIndicator.style.width = `${radius * 2}px`;
                 targetingIndicator.style.height = `${radius * 2}px`;
                 targetingIndicator.style.display = 'block';
                 targetingIndicator.style.borderColor = 'var(--accent-red)';
                 targetingIndicator.style.backgroundColor = 'rgba(231, 76, 60, 0.2)';
                 canvas.addEventListener('mousemove', updateTargetingIndicator);
             }
             canvas.addEventListener('mousedown', handleSpellCast, { once: true });
        }
         function updateTargetingIndicator(event) { /* ... (no changes) ... */
             if (!isTargetingSpell || !currentSpellType || !targetingIndicator || !canvas) return;
             const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top;
             const indicatorSize = targetingIndicator.offsetWidth;
             const clampedX = Math.max(indicatorSize / 2, Math.min(canvas.width - indicatorSize / 2, x));
             const clampedY = Math.max(indicatorSize / 2, Math.min(canvas.height - indicatorSize / 2, y));
             targetingIndicator.style.left = `${clampedX - indicatorSize / 2}px`;
             targetingIndicator.style.top = `${clampedY - indicatorSize / 2}px`;
         }
        function handleSpellCast(event) { /* ... (no changes) ... */
             if (!isTargetingSpell || !currentSpellType || !canvas) return;
             event.preventDefault();
             const rect = canvas.getBoundingClientRect(); const targetX = event.clientX - rect.left; const targetY = event.clientY - rect.top;
             const spellCard = getCardById(currentSpellType);
             console.log(`Casting ${currentSpellType} at (${targetX.toFixed(0)}, ${targetY.toFixed(0)})`);
             setTimeout(() => { executeSpellEffect(currentSpellType, targetX, targetY); }, spellCard.stats.delay || 0);
             isTargetingSpell = false; currentSpellType = null; canvas.style.cursor = 'default';
             if (targetingIndicator) targetingIndicator.style.display = 'none';
             canvas.removeEventListener('mousemove', updateTargetingIndicator);
             updateBattleButtons();
        }
        function executeSpellEffect(spellId, x, y) { /* ... (no changes) ... */
            const spellCard = getCardById(spellId); if (!spellCard || spellCard.type !== 'spell') return;
            console.log(`%cExecuting ${spellId} effect at (${x.toFixed(0)}, ${y.toFixed(0)})`, "color: orange; font-weight: bold;");
            if (spellId === 'fireball') {
                const radius = spellCard.stats.radius; const damage = spellCard.stats.damage;
                const canTargetAir = spellCard.stats.targets?.includes('air'); const canTargetGround = spellCard.stats.targets?.includes('ground');
                attackEffects.push({ type: 'explosion', x: x, y: y, radius: radius, duration: 400, startTime: Date.now(), color: 'rgba(255, 100, 0, 0.8)' });
                const targetsToCheck = [...enemyUnits, ...enemyTowers, ...enemyBuildings];
                targetsToCheck.forEach(target => {
                    if (!target || target.hp <= 0) return; const targetIsAir = target.stats?.isAir; if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                    const targetCenterX = target.x + (target.isTower || target.isBuilding ? target.width / 2 : 0); const targetCenterY = target.y; const dist = distance(x, y, targetCenterX, targetCenterY);
                    if (dist <= radius) { /* ... damage logic ... */ target.hp -= damage; attackEffects.push({ type: 'flash', x: targetCenterX, y: targetCenterY, radius: (target.width || target.stats?.size || 10) * 0.3, duration: 150, startTime: Date.now() }); }
                });
            } else if (spellId === 'log') {
                const logStats = spellCard.stats; const startX = 0; const logYPosition = canvas.height / 2;
                logProjectiles.push({ id: `log_${Date.now()}`, x: startX, y: logYPosition, startX: startX, stats: logStats, color: 'var(--log-color)', direction: 1, startTime: Date.now(), hitTargets: [] });
            }
            updateDisplays(); cleanupDeadUnits();
        }

        // --- Building Placement Logic ---
        function startBuildingPlacement(buildingId) { /* ... (no changes) ... */
            const buildingCard = getCardById(buildingId);
            if (isTargetingSpell || isPlacingBuilding || !canvas || !buildingCard || buildingCard.type !== 'building') return;
            console.log(`Placing ${buildingId}...`);
            isPlacingBuilding = true; currentBuildingType = buildingId; canvas.style.cursor = 'copy';
            updateBattleButtons();
            const size = buildingCard.stats.size || PLACEMENT_TILE_SIZE;
            placementIndicator.style.width = `${size}px`; placementIndicator.style.height = `${size}px`;
            placementIndicator.style.display = 'block';
            canvas.addEventListener('mousemove', updatePlacementIndicator);
            canvas.addEventListener('mousedown', handleBuildingPlace, { once: true });
        }
        function updatePlacementIndicator(event) { /* ... (no changes) ... */
            if (!isPlacingBuilding || !currentBuildingType || !placementIndicator || !canvas) return;
            const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top;
            const card = getCardById(currentBuildingType); const size = card.stats.size || PLACEMENT_TILE_SIZE;
            const indicatorX = x - size / 2; const indicatorY = y - size / 2;
            placementIndicator.style.left = `${indicatorX}px`; placementIndicator.style.top = `${indicatorY}px`;
            if (isValidPlacement(x, y, true)) { placementIndicator.classList.remove('invalid'); }
            else { placementIndicator.classList.add('invalid'); }
        }
        function handleBuildingPlace(event) { /* ... (no changes) ... */
            if (!isPlacingBuilding || !currentBuildingType || !canvas) return;
            event.preventDefault();
            const rect = canvas.getBoundingClientRect(); const targetX = event.clientX - rect.left; const targetY = event.clientY - rect.top;
            if (isValidPlacement(targetX, targetY, true)) {
                console.log(`Placing ${currentBuildingType} at (${targetX.toFixed(0)}, ${targetY.toFixed(0)})`);
                deployBuilding(currentBuildingType, true, targetX, targetY);
            } else {
                console.log(`Invalid placement location for ${currentBuildingType}.`);
                playerElixir += getCardById(currentBuildingType).cost; updateDisplays();
            }
            isPlacingBuilding = false; currentBuildingType = null; canvas.style.cursor = 'default';
            if (placementIndicator) placementIndicator.style.display = 'none';
            canvas.removeEventListener('mousemove', updatePlacementIndicator);
            updateBattleButtons();
        }
        function isValidPlacement(x, y, isPlayer) { /* ... (no changes) ... */
            const card = getCardById(currentBuildingType); if (!card) return false;
            const size = card.stats.size || PLACEMENT_TILE_SIZE; const halfSize = size / 2;
            if (isPlayer && x > PLAYER_SIDE_X_LIMIT) return false;
            if (!isPlayer && x < PLAYER_SIDE_X_LIMIT) return false;
            if (x - halfSize < 0 || x + halfSize > canvas.width || y - halfSize < 0 || y + halfSize > canvas.height) return false;
            const checkEntities = isPlayer ? [...playerTowers, ...playerBuildings] : [...enemyTowers, ...enemyBuildings];
            const minDistance = size * 0.8;
            for (const entity of checkEntities) {
                 if (!entity || entity.hp <= 0) continue;
                 const entitySize = entity.isTower ? (entity.isKingTower ? KING_TOWER_WIDTH : PRINCESS_TOWER_WIDTH) : entity.stats?.size || PLACEMENT_TILE_SIZE;
                 const entityX = entity.x + (entity.isTower ? entity.width/2 : 0); const entityY = entity.y;
                 if (distance(x, y, entityX, entityY) < (halfSize + entitySize / 2 + 10)) { return false; }
            }
            return true;
        }


        function updateElixir() { /* ... (no changes) ... */
            if (gameOver || isTiebreakerActive) return;
            if (playerElixir < MAX_ELIXIR) { playerElixir = Math.min(MAX_ELIXIR, playerElixir + ELIXIR_REGEN_RATE); }
            aiElixir = Math.min(MAX_ELIXIR, aiElixir + ELIXIR_REGEN_RATE);
            updateDisplays(); updateBattleButtons();
        }
        // --- *** MODIFIED: deployUnit adds attack state properties *** ---
        function deployUnit(cardId, isPlayer, deployX = null, deployY = null) {
             const card = getCardById(cardId);
             if (!card || card.type !== 'unit') { console.error("Invalid unit type for deployment:", cardId); return; }

             let spawnXBase, spawnYBase;
             if (deployX !== null && deployY !== null) { spawnXBase = deployX; spawnYBase = deployY; }
             else { const kingTower = isPlayer ? playerTowers[1] : enemyTowers[1]; spawnXBase = kingTower.x + kingTower.width + 20; spawnYBase = kingTower.y + (Math.random() * 80 - 40); }

             // --- MODIFICATION START: Add animation state properties ---
             const addAnimationState = (obj) => {
                 obj.isAttacking = false; obj.attackAnimationEndTime = 0; // Existing attack state
                 obj.isMoving = false; obj.walkFrame = 0; // NEW: Walk state
                 obj.isDying = false; obj.deathAnimationEndTime = 0; // NEW: Death state
                 return obj;
             };
             // --- MODIFICATION END ---

             if (card.stats.spawnCount && card.stats.unitStats) { // Multi-spawn
                 const unitStats = card.stats.unitStats; const spawnCount = card.stats.spawnCount; const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
                 for (let i = 0; i < spawnCount; i++) {
                     const spawnYOffset = (Math.random() - 0.5) * 30 * spawnCount; const spawnXOffset = (Math.random() - 0.5) * 10;
                     let newUnit = { id: `${cardId}_${Date.now()}_${Math.random()}_${i}`, type: cardId, stats: { ...unitStats }, x: spawnXBase + spawnXOffset, y: spawnYBase + spawnYOffset, isPlayer: isPlayer, hp: unitStats.hp, maxHp: unitStats.maxHp, color: isPlayer ? unitStats.color : enemyColor, target: null, lastAttackTime: 0, };
                     newUnit = addAnimationState(newUnit); // Add animation state
                     if (isPlayer) playerUnits.push(newUnit); else enemyUnits.push(newUnit);
                 }
             } else { // Single-spawn
                 const stats = card.stats; const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
                 let newUnit = { id: `${cardId}_${Date.now()}_${Math.random()}`, type: cardId, stats: { ...stats }, x: spawnXBase, y: spawnYBase, isPlayer: isPlayer, hp: stats.hp, maxHp: stats.maxHp, color: isPlayer ? stats.color : enemyColor, target: null, lastAttackTime: 0, };
                 newUnit = addAnimationState(newUnit); // Add animation state
                 if (isPlayer) playerUnits.push(newUnit); else enemyUnits.push(newUnit);
             }
             // console.log(`${isPlayer ? 'Player' : 'AI'} deployed ${card.name}`);
         }
        // --- *** MODIFIED: deployBuilding adds attack state properties *** ---
        function deployBuilding(cardId, isPlayer, x, y) {
            const card = getCardById(cardId);
            if (!card || card.type !== 'building') { console.error("Invalid building type for deployment:", cardId); return; }

            const stats = card.stats;
            const enemyColor = ENEMY_COLORS[cardId] || '#FFFFFF';
            const newBuilding = {
                id: `${cardId}_${Date.now()}_${Math.random()}`,
                type: cardId,
                stats: { ...stats },
                x: x, y: y,
                isPlayer: isPlayer,
                hp: stats.hp, maxHp: stats.maxHp,
                color: isPlayer ? stats.color : enemyColor,
                target: null, lastAttackTime: 0,
                spawnTime: Date.now(),
                isBuilding: true,
                width: stats.size, height: stats.size,
                isAttacking: false, // Add attack state
                attackAnimationEndTime: 0 // Add attack state
            };

            if (isPlayer) { playerBuildings.push(newBuilding); }
            else { enemyBuildings.push(newBuilding); }
            console.log(`${isPlayer ? 'Player' : 'AI'} deployed building ${card.name}`);
        }


        // --- Targeting, Movement, Attack Logic ---
        function findTarget(unit, potentialEnemyUnits, potentialEnemyTowers, potentialEnemyBuildings) {
             let closestTarget = null; let minDistance = Infinity;
             // --- MODIFICATION START: Check isDying ---
             if (!unit || !unit.stats || unit.hp <= 0 || unit.isDying) return null;
             // --- MODIFICATION END ---

             const unitRange = unit.stats.range; const preference = unit.stats.targetPreference;
             const canTargetAir = unit.stats.targets?.includes('air') ?? true; const canTargetGround = unit.stats.targets?.includes('ground') ?? true;
             let preferredTargets = []; let otherTargets = [];
             const allEnemies = [...potentialEnemyUnits, ...potentialEnemyTowers, ...potentialEnemyBuildings];

             allEnemies.forEach(target => {
                 // --- MODIFICATION START: Check target.isDying ---
                 if (!target || target.hp <= 0 || target.isDying) return;
                 // --- MODIFICATION END ---
                 const targetIsAir = target.stats?.isAir; const targetIsBuilding = target.isBuilding || target.isTower;
                 if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 if (preference === 'building' && targetIsBuilding) { preferredTargets.push(target); }
                 else if (preference !== 'building' || !targetIsBuilding) { otherTargets.push(target); }
             });
             // ... (rest of targeting logic remains the same) ...
             preferredTargets.forEach(target => { const targetCenterX = target.x + (target.width ? target.width / 2 : 0); const targetCenterY = target.y; const d = distance(unit.x, unit.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; } });
             if (!closestTarget || minDistance > unitRange) { if (minDistance > unitRange) minDistance = Infinity; otherTargets.forEach(target => { const targetCenterX = target.x + (target.width ? target.width / 2 : 0); const targetCenterY = target.y; const d = distance(unit.x, unit.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; } }); }
             if (closestTarget && minDistance > unitRange) { return null; }
             return closestTarget;
        }
        
         function findTowerTarget(tower, potentialEnemyUnits, potentialEnemyBuildings) { /* ... (no changes) ... */
             let closestTarget = null; let minDistance = tower.range; if (!tower || tower.hp <= 0) return null;
             const canTargetAir = tower.targets?.includes('air'); const canTargetGround = tower.targets?.includes('ground');
             const allEnemies = [...potentialEnemyUnits, ...potentialEnemyBuildings];
             allEnemies.forEach(target => {
                  if(!target || target.hp <= 0) return;
                  const targetIsAir = target.stats?.isAir; if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 const targetCenterX = target.x + (target.isBuilding ? target.width / 2 : 0); const targetCenterY = target.y;
                 const d = distance(tower.x + tower.width / 2, tower.y, targetCenterX, targetCenterY); if (d < minDistance) { minDistance = d; closestTarget = target; }
             });
             return closestTarget;
         }
         function findBuildingTarget(building, potentialEnemyUnits) {
             let closestTarget = null; let minDistance = building.stats.range;
             if (!building || building.hp <= 0) return null;
             const canTargetAir = building.stats.targets?.includes('air'); const canTargetGround = building.stats.targets?.includes('ground');

             potentialEnemyUnits.forEach(target => {
                  // --- MODIFICATION START: Check target.isDying ---
                  if(!target || target.hp <= 0 || target.isDying) return;
                  // --- MODIFICATION END ---
                  const targetIsAir = target.stats?.isAir; if (targetIsAir && !canTargetAir) return; if (!targetIsAir && !canTargetGround) return;
                 const d = distance(building.x, building.y, target.x, target.y); if (d < minDistance) { minDistance = d; closestTarget = target; }
             });
             return closestTarget;
         }

        // --- *** MODIFIED: updateUnits sets attack state *** ---
        function updateUnits(units, enemyUnitsList, enemyTowersList, enemyBuildingsList) {
            if (isTiebreakerActive) return;
            const currentTime = Date.now();

            for (let i = units.length - 1; i >= 0; i--) {
                const unit = units[i];
                 if (!unit || !unit.stats) continue; // Process even if HP is 0 to handle death animation trigger

                 // --- Handle Death State Trigger ---
                 if (unit.hp <= 0 && !unit.isDying) {
                     unit.isDying = true;
                     unit.deathAnimationEndTime = currentTime + DEATH_ANIMATION_DURATION;
                     unit.target = null; // Stop targeting
                     console.log(`Unit ${unit.id} started dying.`);
                     // Don't remove from array here, let gameLoop handle it after animation
                 }

                 // Skip updates if dying
                 if (unit.isDying) continue;

                // Reset attack state if animation time ended (moved to gameLoop)

                // Handle Pushback
                if (unit.isPushedBack && currentTime < unit.pushbackEndTime) {
                    unit.x += unit.pushbackVelocityX; unit.y += unit.pushbackVelocityY;
                    unit.x = Math.max(unit.stats.size / 2, Math.min(canvas.width - unit.stats.size / 2, unit.x));
                    unit.y = Math.max(unit.stats.size / 2, Math.min(canvas.height - unit.stats.size / 2, unit.y));
                    unit.isMoving = true; // Considered moving while pushed
                    continue;
                } else if (unit.isPushedBack) {
                    unit.isPushedBack = false;
                }

                 // Targeting
                 let targetNeedsUpdate = !unit.target || unit.target.hp <= 0 || unit.target.isDying; // Check if target is dying
                 if (targetNeedsUpdate) {
                     unit.target = findTarget(unit, enemyUnitsList, enemyTowersList, enemyBuildingsList);
                 }

                // Attacking
                let performedAttackThisFrame = false;
                if (unit.target) {
                    const targetWidth = unit.target.width || (unit.target.stats ? unit.target.stats.size : 0);
                    const targetCenterX = unit.target.x + (targetWidth / 2);
                    const targetCenterY = unit.target.y;
                    const distToTarget = distance(unit.x, unit.y, targetCenterX, targetCenterY);

                    if (distToTarget <= unit.stats.range) {
                        performedAttackThisFrame = true; // In range
                        if (currentTime - unit.lastAttackTime >= unit.stats.attackSpeed) {
                             unit.isAttacking = true; unit.attackAnimationEndTime = currentTime + ATTACK_ANIMATION_DURATION;
                             if (unit.stats.range > 30) { projectiles.push({ /* ... */ }); }
                             else { unit.target.hp -= unit.stats.damage; }
                             unit.lastAttackTime = currentTime;
                             if (unit.target.hp <= 0) { unit.target = null; performedAttackThisFrame = false; }
                        }
                    } else {
                         unit.target = null; // Target moved out of range
                         performedAttackThisFrame = false;
                     }
                } else {
                    performedAttackThisFrame = false; // No target
                }

                 // Movement
                 const previousX = unit.x;
                 const previousY = unit.y;
                 if (!performedAttackThisFrame) { // Only move if not in range or attack on cooldown
                     let moveTarget = unit.target;
                     if (!moveTarget) { moveTarget = findTarget(unit, enemyUnitsList, enemyTowersList, enemyBuildingsList); }

                     if (moveTarget) {
                         const targetCenterX = moveTarget.x + (moveTarget.width ? moveTarget.width / 2 : 0);
                         const angle = Math.atan2(moveTarget.y - unit.y, targetCenterX - unit.x);
                         unit.x += Math.cos(angle) * unit.stats.speed;
                         unit.y += Math.sin(angle) * unit.stats.speed;
                     } else {
                         const direction = unit.isPlayer ? 1 : -1;
                         unit.x += unit.stats.speed * direction;
                     }
                 }

                 // --- Update Movement State ---
                 unit.isMoving = (unit.x !== previousX || unit.y !== previousY);
                 // --- End Update Movement State ---


                 // Boundary checks
                 unit.x = Math.max(unit.stats.size / 2, Math.min(canvas.width - unit.stats.size / 2, unit.x));
                 unit.y = Math.max(unit.stats.size / 2, Math.min(canvas.height - unit.stats.size / 2, unit.y));
            }
        }

        // --- *** MODIFIED: updateTowers sets attack state *** ---
         function updateTowers(towers, enemyUnitsList, enemyBuildingsList) {
             if (isTiebreakerActive) return;
             const currentTime = Date.now();
             towers.forEach(tower => {
                 // Reset attack state if animation time ended
                 if (tower.isAttacking && currentTime > tower.attackAnimationEndTime) {
                     tower.isAttacking = false;
                 }

                 if (tower.hp > 0) {
                     const target = findTowerTarget(tower, enemyUnitsList, enemyBuildingsList);
                     if (target && currentTime - tower.lastAttackTime >= tower.attackSpeed) {
                         // --- Set Attack State ---
                         tower.isAttacking = true;
                         tower.attackAnimationEndTime = currentTime + ATTACK_ANIMATION_DURATION;
                         // --- End Set Attack State ---

                         const projectileStartX = tower.x + tower.width / 2;
                         projectiles.push({ x: projectileStartX, y: tower.y, target: target, speed: 6, damage: tower.damage, color: tower.color, size: 6, isPlayerProjectile: tower.color === playerTowers[1].color });
                         tower.lastAttackTime = currentTime;
                         // attackEffects.push({ type: 'flash', x: projectileStartX, y: tower.y, radius: 4, duration: 100, startTime: currentTime }); // Replaced by isAttacking visual
                     }
                 }
             });
         }

        // --- *** MODIFIED: updateBuildings sets attack state *** ---
         function updateBuildings(buildings, enemyUnitsList) {
             if (isTiebreakerActive) return;
             const currentTime = Date.now();
             for (let i = buildings.length - 1; i >= 0; i--) {
                 const building = buildings[i];
                 if (!building || building.hp <= 0) continue;

                 // Reset attack state if animation time ended
                 if (building.isAttacking && currentTime > building.attackAnimationEndTime) {
                     building.isAttacking = false;
                 }

                 // Check lifetime
                 if (currentTime - building.spawnTime > building.stats.lifetime) {
                     building.hp = 0; console.log(`${building.type} ${building.id} expired.`);
                     attackEffects.push({ type: 'flash', x: building.x, y: building.y, radius: building.stats.size / 2, duration: 300, startTime: currentTime });
                     continue;
                 }

                 // Targeting and Attacking
                 const target = findBuildingTarget(building, enemyUnitsList);
                 if (target && currentTime - building.lastAttackTime >= building.stats.attackSpeed) {
                     // --- Set Attack State ---
                     building.isAttacking = true;
                     building.attackAnimationEndTime = currentTime + ATTACK_ANIMATION_DURATION;
                     // --- End Set Attack State ---

                     const projectileStartX = building.x; const projectileStartY = building.y;
                     projectiles.push({ x: projectileStartX, y: projectileStartY, target: target, speed: 7, damage: building.stats.damage, color: building.color, size: 7, isPlayerProjectile: building.isPlayer });
                     building.lastAttackTime = currentTime;
                     // attackEffects.push({ type: 'flash', x: projectileStartX, y: projectileStartY, radius: 5, duration: 100, startTime: currentTime }); // Replaced by isAttacking visual
                 }
             }
         }

        function updateLogProjectiles(logProjectilesList, enemyUnitsList, playerUnitsList) { /* ... (no changes, logs commented out) ... */
            if (isTiebreakerActive) return;
            const currentTime = Date.now();
            for (let i = logProjectilesList.length - 1; i >= 0; i--) {
                const log = logProjectilesList[i]; if (!log) continue;
                log.x += log.stats.speed * log.direction;
                const unitsToCheck = log.direction === 1 ? enemyUnitsList : playerUnitsList;
                const logRect = { x: log.x - 30, y: log.y - log.stats.width / 2, width: 60, height: log.stats.width };
                unitsToCheck.forEach(unit => {
                    // console.log(`Log Check: Unit ${unit?.id} (${unit?.type}), HP=${unit?.hp}, isGround=${isGroundUnit(unit)}, alreadyHit=${log.hitTargets.includes(unit?.id)}`);
                    if (!unit || unit.hp <= 0 || !isGroundUnit(unit) || log.hitTargets.includes(unit.id)) return;
                    const unitRect = { x: unit.x - unit.stats.size / 2, y: unit.y - unit.stats.size / 2, width: unit.stats.size, height: unit.stats.size };
                    // console.log(`Log Collision Check: Log Rect (x:${logRect.x.toFixed(1)}, y:${logRect.y.toFixed(1)}, w:${logRect.width}, h:${logRect.height}) vs Unit ${unit.id} Rect (x:${unitRect.x.toFixed(1)}, y:${unitRect.y.toFixed(1)}, w:${unitRect.width}, h:${unitRect.height})`);
                    if (logRect.x < unitRect.x + unitRect.width && logRect.x + logRect.width > unitRect.x && logRect.y < unitRect.y + unitRect.height && logRect.y + logRect.height > unitRect.y) {
                        // console.log(`%c!!! LOG HIT DETECTED: Log ${log.id} hit Unit ${unit.id} !!!`, "color: lime; font-weight: bold;");
                        unit.hp -= log.stats.damage; log.hitTargets.push(unit.id);
                        const pushbackAngle = Math.atan2(unit.y - log.y, unit.x - log.x); const pushSpeed = log.stats.pushbackStrength;
                        unit.isPushedBack = true; unit.pushbackEndTime = currentTime + log.stats.pushbackDuration;
                        unit.pushbackVelocityX = Math.cos(pushbackAngle) * pushSpeed; unit.pushbackVelocityY = Math.sin(pushbackAngle) * pushSpeed;
                        attackEffects.push({ type: 'flash', x: unit.x, y: unit.y, radius: unit.stats.size / 2, duration: 150, startTime: currentTime });
                    }
                });
                const distanceTraveled = Math.abs(log.x - log.startX);
                if (distanceTraveled >= log.stats.travelDistance || log.x < -logRect.width || log.x > canvas.width + logRect.width) {
                    logProjectilesList.splice(i, 1);
                }
            }
        }
        function updateProjectiles() { /* ... (no changes) ... */
             if (isTiebreakerActive) return;
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); continue; }
                const targetWidth = p.target.isTower || p.target.isBuilding ? p.target.width : (p.target.stats ? p.target.stats.size : 0);
                const targetX = p.target.x + (targetWidth / 2); const targetY = p.target.y;
                const angle = Math.atan2(targetY - p.y, targetX - p.x);
                p.x += Math.cos(angle) * p.speed; p.y += Math.sin(angle) * p.speed;
                const hitRadius = (targetWidth || p.target.stats?.size || 10) / 2 * 0.8;
                if (distance(p.x, p.y, targetX, targetY) < hitRadius) {
                     p.target.hp -= p.damage;
                     attackEffects.push({ type: 'flash', x: targetX, y: targetY, radius: hitRadius * 1.5, duration: 100, startTime: Date.now() });
                     projectiles.splice(i, 1);
                 }
                 else if (p.x < -p.size || p.x > canvas.width + p.size || p.y < -p.size || p.y > canvas.height + p.size) { projectiles.splice(i, 1); }
            }
        }
         function cleanupDeadUnits() {
             // Units are cleaned up in gameLoop after death animation
             playerBuildings = playerBuildings.filter(building => building && building.hp > 0);
             enemyBuildings = enemyBuildings.filter(building => building && building.hp > 0);
         }
         function updateAttackEffects(currentTime) { /* ... (no changes) ... */
             attackEffects = attackEffects.filter(effect => currentTime - effect.startTime <= effect.duration);
         }
         function getThreateningPlayerUnits(targetStructure, detectionRange = 150) {
            return playerUnits.filter(unit => {
                if (!unit || unit.hp <= 0) return false;
                // Ensure targetStructure is valid and has coordinates
                if (!targetStructure || typeof targetStructure.x === 'undefined' || typeof targetStructure.y === 'undefined') return false;
                const targetX = targetStructure.x + (targetStructure.width ? targetStructure.width / 2 : 0);
                const targetY = targetStructure.y;
                return distance(unit.x, unit.y, targetX, targetY) < detectionRange;
            });
        }
        
        function findBestCounter(unitToCounter, availableCards, currentElixir) {
            // Try specific counter first
            const counterCardId = AI_COUNTERS[unitToCounter.type] || AI_COUNTERS['default'];
            const counterCard = getCardById(counterCardId);
            if (counterCard && availableCards.includes(counterCardId) && currentElixir >= counterCard.cost) {
                return counterCard;
            }
            // Fallback: find cheapest available unit if direct counter fails or not affordable
            let cheapestCard = null;
            let minCost = Infinity;
            availableCards.forEach(cardId => {
                const card = getCardById(cardId);
                // Ensure card exists, is implemented, is a unit, and is affordable
                if (card && card.implemented && card.type === 'unit' && card.cost < minCost && currentElixir >= card.cost) {
                    minCost = card.cost;
                    cheapestCard = card;
                }
            });
            return cheapestCard; // Might return null if nothing is affordable/available
        }
        
        function findDefensivePlacement(threatenedStructure, cardToDeploy) {
            const buffer = 30;
            // Place slightly behind (more towards AI king tower) the structure
            let placeX = threatenedStructure.x + buffer; // Place to the right (further back for AI)
            const placeY = threatenedStructure.y + (Math.random() * 60 - 30); // Slight Y variance

            // Ensure placement is on AI side and within bounds
            const cardSize = cardToDeploy?.stats?.size || PLACEMENT_TILE_SIZE; // Use card size if available
            placeX = Math.max(PLAYER_SIDE_X_LIMIT + cardSize / 2 + 5, placeX); // Ensure on AI side
            placeX = Math.min(canvas.width - cardSize / 2 - 5, placeX); // Ensure within right bound
            const finalY = Math.max(cardSize / 2 + 5, Math.min(canvas.height - cardSize / 2 - 5, placeY)); // Ensure within top/bottom bounds

            // Basic check against existing AI buildings/towers - could be improved with isValidPlacement
            let tooClose = false;
            [...enemyTowers, ...enemyBuildings].forEach(entity => {
                 if (!entity || entity.hp <= 0) return;
                 if (distance(placeX, finalY, entity.x + (entity.width ? entity.width/2 : 0), entity.y) < cardSize) {
                     tooClose = true;
                 }
            });
            // If too close, adjust slightly? For now, just return calculated position.
            // A better approach would integrate isValidPlacement(placeX, finalY, false)

            return { x: placeX, y: finalY };
        }
        
        function findOffensivePlacement(targetStructure, cardToDeploy) {
             // Place near the middle line, towards the target structure's Y
             let placeX = PLAYER_SIDE_X_LIMIT + 40 + (Math.random() * 30); // Just across the middle
             let placeY = targetStructure ? targetStructure.y + (Math.random() * 80 - 40) : canvas.height / 2; // Aim towards target Y or center

             // Ensure placement is within bounds
             const cardSize = cardToDeploy?.stats?.size || PLACEMENT_TILE_SIZE;
             placeX = Math.max(PLAYER_SIDE_X_LIMIT + cardSize / 2 + 5, placeX); // Ensure on AI side
             placeX = Math.min(canvas.width - cardSize / 2 - 5, placeX); // Ensure within right bound
             placeY = Math.max(cardSize / 2 + 5, Math.min(canvas.height - cardSize / 2 - 5, placeY)); // Ensure within top/bottom bounds

             return { x: placeX, y: placeY };
        }
        
        function updateAI() {
            if (gameOver || isTiebreakerActive || isPlacingBuilding || isTargetingSpell) return; // Don't act if game/player busy

            const aiKingTower = enemyTowers[1];
            const availableCards = AI_DECK; // AI uses its fixed deck
            let actionTaken = false;

            // --- 1. High Priority Defense (King Tower) ---
            const kingThreats = getThreateningPlayerUnits(aiKingTower, 180); // Larger detection range for king
            if (kingThreats.length > 0) {
                const mainThreat = kingThreats.sort((a, b) => distance(a.x, a.y, aiKingTower.x, aiKingTower.y) - distance(b.x, b.y, aiKingTower.x, aiKingTower.y))[0]; // Target closest threat
                const counterCard = findBestCounter(mainThreat, availableCards, aiElixir);
                if (counterCard) {
                    const placePos = findDefensivePlacement(aiKingTower, counterCard);
                    if (counterCard.type === 'building') {
                         // Use isValidPlacement for AI side
                         if (isValidPlacement(placePos.x, placePos.y, false)) {
                             aiElixir -= counterCard.cost;
                             deployBuilding(counterCard.id, false, placePos.x, placePos.y);
                             actionTaken = true;
                             console.log(`AI Defense (King): Deploying ${counterCard.name} against ${mainThreat.type}`);
                         } else { console.log("AI Defense (King): Invalid placement for building."); }
                    } else { // Unit
                        aiElixir -= counterCard.cost;
                        deployUnit(counterCard.id, false, placePos.x, placePos.y); // Pass coords
                        actionTaken = true;
                        console.log(`AI Defense (King): Deploying ${counterCard.name} against ${mainThreat.type}`);
                    }
                }
            }

            // --- 2. General Defense (Other Towers/Buildings) ---
            if (!actionTaken) {
                const structuresToDefend = [...enemyTowers.filter(t => !t.isKingTower && t.hp > 0), ...enemyBuildings.filter(b => b.hp > 0)];
                structuresToDefend.sort((a,b) => a.hp - b.hp); // Prioritize lower HP structures slightly? Or closest threat?

                for (const structure of structuresToDefend) {
                    const threats = getThreateningPlayerUnits(structure, 150);
                    if (threats.length > 0) {
                        const closestThreat = threats.sort((a, b) => distance(a.x, a.y, structure.x, structure.y) - distance(b.x, b.y, structure.x, structure.y))[0];
                        const counterCard = findBestCounter(closestThreat, availableCards, aiElixir);
                        if (counterCard) {
                            const placePos = findDefensivePlacement(structure, counterCard);
                             if (counterCard.type === 'building') {
                                 if (isValidPlacement(placePos.x, placePos.y, false)) {
                                     aiElixir -= counterCard.cost;
                                     deployBuilding(counterCard.id, false, placePos.x, placePos.y);
                                     actionTaken = true;
                                     console.log(`AI Defense: Deploying ${counterCard.name} against ${closestThreat.type} near ${structure.id}`);
                                 } else { console.log("AI Defense: Invalid placement for building."); }
                            } else { // Unit
                                aiElixir -= counterCard.cost;
                                deployUnit(counterCard.id, false, placePos.x, placePos.y);
                                actionTaken = true;
                                console.log(`AI Defense: Deploying ${counterCard.name} against ${closestThreat.type} near ${structure.id}`);
                            }
                            if(actionTaken) break; // Only handle one defense per cycle
                        }
                    }
                }
            }

            // --- 3. Build Offensive Push (High Elixir) ---
            if (!actionTaken && aiElixir >= 7) {
                 const tankCardId = availableCards.find(id => ['giant', 'tank'].includes(id)); // Find Giant or generic tank
                 const tankCard = tankCardId ? getCardById(tankCardId) : null;

                 if (tankCard && aiElixir >= tankCard.cost) {
                     let targetStructure = playerTowers.filter(t => t.hp > 0).sort((a,b) => a.hp - b.hp)[0] || playerBuildings.filter(b => b.hp > 0).sort((a,b) => a.hp - b.hp)[0]; // Target lowest HP structure
                     if (!targetStructure) targetStructure = playerTowers[1]; // Fallback to king tower

                     const placePos = findOffensivePlacement(targetStructure, tankCard);
                     aiElixir -= tankCard.cost;
                     deployUnit(tankCard.id, false, placePos.x, placePos.y);
                     actionTaken = true;
                     console.log(`AI Offense: Starting push with ${tankCard.name}`);
                     // Simple: Try to deploy archer behind if affordable immediately
                     const archerCard = getCardById('archer');
                     if (availableCards.includes('archer') && aiElixir >= archerCard.cost) {
                         setTimeout(() => { // Deploy slightly later
                            if (aiElixir >= archerCard.cost) { // Check elixir again
                                aiElixir -= archerCard.cost;
                                deployUnit('archer', false, placePos.x - 15, placePos.y); // Place behind tank
                                console.log(`AI Offense: Adding Archer support`);
                                updateDisplays(); updateBattleButtons();
                            }
                         }, 500); // 0.5 sec delay
                     }
                 }
            }

            // --- 4. Opportunistic Attack (Mid Elixir) ---
             if (!actionTaken && aiElixir >= 4) {
                 const attackCardId = availableCards.find(id => id === 'hogrider'); // Try Hog Rider
                 const attackCard = attackCardId ? getCardById(attackCardId) : null;

                 if (attackCard && aiElixir >= attackCard.cost && Math.random() < 0.4) { // Add randomness to hog deployment
                      let targetStructure = playerBuildings.filter(b => b.hp > 0).sort((a,b) => a.hp - b.hp)[0] || playerTowers.filter(t => t.hp > 0).sort((a,b) => a.hp - b.hp)[0]; // Target lowest HP building/tower
                      if (!targetStructure) targetStructure = playerTowers[1];

                      const placePos = findOffensivePlacement(targetStructure, attackCard);
                      aiElixir -= attackCard.cost;
                      deployUnit(attackCard.id, false, placePos.x, placePos.y);
                      actionTaken = true;
                      console.log(`AI Offense: Deploying ${attackCard.name}`);
                 }
             }

             // --- 5. Cycle / Prevent Elixir Waste ---
             if (!actionTaken && aiElixir >= 9) {
                  let cheapestCard = null; let minCost = Infinity;
                  availableCards.forEach(cardId => {
                      const card = getCardById(cardId);
                      if (card && card.implemented && card.cost < minCost && aiElixir >= card.cost) {
                          minCost = card.cost; cheapestCard = card;
                      }
                  });
                  if (cheapestCard) {
                       aiElixir -= cheapestCard.cost;
                       const placePos = findDefensivePlacement(enemyTowers[1], cheapestCard); // Default placement near back
                       if (cheapestCard.type === 'unit') deployUnit(cheapestCard.id, false, placePos.x, placePos.y);
                       else if (cheapestCard.type === 'building' && isValidPlacement(placePos.x, placePos.y, false)) deployBuilding(cheapestCard.id, false, placePos.x, placePos.y);
                       // AI doesn't cycle spells yet
                       actionTaken = true;
                       console.log(`AI Cycle: Deploying cheapest card ${cheapestCard.name}`);
                  }
             }


            // Update displays if action was taken
            if (actionTaken) {
                updateDisplays();
                updateBattleButtons();
            }
        }


         // --- Game Over Check ---
         function checkGameOver(timeUp = false) { /* ... (no changes) ... */
             if (gameOver) return; let winner = null;
             const playerKingTower = playerTowers[1]; const enemyKingTower = enemyTowers[1];
             if (enemyKingTower.hp <= 0) { winner = 'Player'; } else if (playerKingTower.hp <= 0) { winner = 'Enemy'; }
             else if (timeUp && !isTiebreakerActive) {
                 console.log("Time's up! Checking tower HP for tiebreaker.");
                 if (playerKingTower.hp > enemyKingTower.hp) { winner = 'Player'; } else if (enemyKingTower.hp > playerKingTower.hp) { winner = 'Enemy'; } else { startTiebreaker(); return; }
             }
             if (winner) {
                 gameOver = true; stopGameTimers(); console.log("Game Over! Winner:", winner);
                 if (winner === 'Player') { showMessage("You Win!"); } else if (winner === 'Enemy') { showMessage("You Lose!"); }
                 updateBattleButtons(); console.log("Switching back to deck builder in 3 seconds..."); setTimeout(switchToDeckBuilder, 3000);
             }
         }

         // --- Tiebreaker Functions ---
         function startTiebreaker() { /* ... (no changes) ... */
             if (isTiebreakerActive) return; console.log("TIEBREAKER STARTED!"); isTiebreakerActive = true;
             clearInterval(elixirIntervalId); elixirIntervalId = null; clearInterval(aiIntervalId); aiIntervalId = null; clearInterval(gameTimerIntervalId); gameTimerIntervalId = null;
             playerUnits = []; enemyUnits = []; projectiles = []; logProjectiles = []; playerBuildings = []; enemyBuildings = []; attackEffects = [];
             updateBattleButtons(); showMessage("TIEBREAKER!"); setTimeout(hideMessage, 2000);
             if (tiebreakerIntervalId) clearInterval(tiebreakerIntervalId); tiebreakerIntervalId = setInterval(drainTowerHp, TIEBREAKER_DRAIN_INTERVAL);
         }
         function drainTowerHp() { /* ... (no changes) ... */
             if (!isTiebreakerActive || gameOver) { stopGameTimers(); return; } const drainAmount = TIEBREAKER_HP_DRAIN_RATE;
             playerTowers[1].hp -= drainAmount; enemyTowers[1].hp -= drainAmount; updateDisplays(); checkGameOver();
         }

         // --- stopGameTimers ---
        function stopGameTimers() { /* ... (no changes) ... */
             clearInterval(elixirIntervalId); elixirIntervalId = null; clearInterval(aiIntervalId); aiIntervalId = null; clearInterval(gameTimerIntervalId); gameTimerIntervalId = null; clearInterval(tiebreakerIntervalId); tiebreakerIntervalId = null;
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
             isTargetingSpell = false; currentSpellType = null; isPlacingBuilding = false; currentBuildingType = null;
             if(canvas) { canvas.style.cursor = 'default'; canvas.removeEventListener('mousemove', updateTargetingIndicator); canvas.removeEventListener('mousemove', updatePlacementIndicator); }
             if (targetingIndicator) targetingIndicator.style.display = 'none'; if (placementIndicator) placementIndicator.style.display = 'none';
             console.log("Game timers and animation frame stopped.");
        }

        // --- Timer Logic ---
        function startGameTimer() { /* ... (no changes) ... */
            gameTimeRemaining = BATTLE_DURATION_SECONDS; updateTimerDisplay(); if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            gameTimerIntervalId = setInterval(() => { if (gameOver) { stopGameTimers(); return; } gameTimeRemaining--; updateTimerDisplay(); if (gameTimeRemaining <= 0 && !gameOver && !isTiebreakerActive) { checkGameOver(true); } }, 1000);
        }
        function updateTimerDisplay() { /* ... (no changes) ... */
            if (!gameTimerDisplay) return; const minutes = Math.floor(Math.max(0, gameTimeRemaining) / 60); const seconds = Math.max(0, gameTimeRemaining) % 60; gameTimerDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // --- Displays and Buttons ---
        function updateDisplays() { /* ... (no changes) ... */
            if (!playerElixirDisplaySpan || !playerTowerHpDisplay || !enemyTowerHpDisplay || !playerElixirBarFill) return;
            playerElixirDisplaySpan.textContent = `Elixir: ${playerElixir} / ${MAX_ELIXIR}`;
            const playerKingHp = playerTowers[1] ? Math.max(0, Math.round(playerTowers[1].hp)) : 'N/A';
            const enemyKingHp = enemyTowers[1] ? Math.max(0, Math.round(enemyTowers[1].hp)) : 'N/A';
            playerTowerHpDisplay.textContent = `King HP: ${playerKingHp}/${KING_TOWER_HP}`;
            enemyTowerHpDisplay.textContent = `King HP: ${enemyKingHp}/${KING_TOWER_HP}`;
            const elixirPercentage = (playerElixir / MAX_ELIXIR) * 100; playerElixirBarFill.style.width = `${elixirPercentage}%`;
        }
         function updateBattleButtons() { /* ... (no changes) ... */
             const buttons = battleControlsContainer ? battleControlsContainer.querySelectorAll('.deploy-button') : [];
             buttons.forEach(button => {
                 const cardId = button.dataset.id; const card = getCardById(cardId);
                 if (card) { button.disabled = !card.implemented || playerElixir < card.cost || gameOver || isTiebreakerActive || isTargetingSpell || isPlacingBuilding; }
                 else { button.disabled = true; }
             });
         }
        function showMessage(text) { /* ... (no changes) ... */ if(messageBox) { messageBox.textContent = text; messageBox.style.display = 'block'; } }
        function hideMessage() { /* ... (no changes) ... */ if(messageBox) messageBox.style.display = 'none'; }

        // --- *** MODIFIED: Game Loop includes resetting attack state *** ---
        function gameLoop() {
            if (gameOver) { animationFrameId = null; return; }
            const currentTime = Date.now();
            gameFrameCounter++; // Increment frame counter for animations
            if (!ctx) { console.error("Canvas context lost during loop!"); stopGameTimers(); return; }

            // --- Reset Attack States & Update Walk Frame ---
            const allUnitsAndStructures = [...playerUnits, ...enemyUnits, ...playerTowers, ...enemyTowers, ...playerBuildings, ...enemyBuildings];
            allUnitsAndStructures.forEach(entity => {
                if (entity) {
                    // Reset attack animation flag if timer expired
                    if (entity.isAttacking && currentTime > entity.attackAnimationEndTime) {
                        entity.isAttacking = false;
                    }
                    // Toggle walk frame for units based on interval (only if it's a unit)
                    if (!entity.isTower && !entity.isBuilding && entity.isMoving && gameFrameCounter % WALK_ANIMATION_INTERVAL === 0) {
                         entity.walkFrame = 1 - (entity.walkFrame || 0); // Toggle 0 and 1
                    }
                }
            });

            // --- Update Phase ---
            try {
                if (!isTiebreakerActive) {
                    updateProjectiles(); updateLogProjectiles(logProjectiles, enemyUnits, playerUnits);
                    updateUnits(playerUnits, enemyUnits, enemyTowers, enemyBuildings); updateUnits(enemyUnits, playerUnits, playerTowers, playerBuildings);
                    updateTowers(playerTowers, enemyUnits, enemyBuildings); updateTowers(enemyTowers, playerUnits, playerBuildings);
                    updateBuildings(playerBuildings, enemyUnits); updateBuildings(enemyBuildings, playerUnits);
                    cleanupDeadUnits(); // Clean up expired/dead buildings ONLY
                }
                updateAttackEffects(currentTime); // Update visual effects (explosions, etc.)
                updateDisplays(); // Update UI text/bars
            } catch (error) { console.error("Error during game update:", error); stopGameTimers(); showMessage("An error occurred!"); return; }

            // --- Drawing Phase ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            try {
                playerTowers.forEach(drawTower); enemyTowers.forEach(drawTower);
                playerBuildings.forEach(drawBuilding); enemyBuildings.forEach(drawBuilding);
                if (!isTiebreakerActive) {
                    playerUnits.forEach(drawUnit); enemyUnits.forEach(drawUnit); // Draw units (handles dying state)
                    projectiles.forEach(drawProjectile); logProjectiles.forEach(drawLogProjectile);
                } else { /* Tiebreaker drawing */ }
                drawAttackEffects(); // Draw separate attack effects
            } catch (error) { console.error("Error during game drawing:", error); stopGameTimers(); showMessage("An error occurred during drawing!"); return; }

            // --- Cleanup Phase (Remove units after death animation) ---
             if (!isTiebreakerActive) {
                 // Iterate backwards for safe removal during iteration
                 for (let i = playerUnits.length - 1; i >= 0; i--) {
                     const unit = playerUnits[i];
                     if (unit.isDying && currentTime > unit.deathAnimationEndTime) {
                         playerUnits.splice(i, 1); // Remove unit after animation
                     }
                 }
                 for (let i = enemyUnits.length - 1; i >= 0; i--) {
                      const unit = enemyUnits[i];
                      if (unit.isDying && currentTime > unit.deathAnimationEndTime) {
                          enemyUnits.splice(i, 1); // Remove unit after animation
                      }
                  }
             }

            // --- Post-Draw Checks ---
            if (!isTiebreakerActive) { checkGameOver(false); }

            // --- Loop Continuation ---
            if (!gameOver) { animationFrameId = requestAnimationFrame(gameLoop); }
             else { animationFrameId = null; }
        }




        // --- Initialization ---
        function initializeGame() {
             console.log("Initializing Battle..."); gameOver = false; playerElixir = 3; aiElixir = AI_STARTING_ELIXIR;
             playerUnits = []; enemyUnits = []; playerBuildings = []; enemyBuildings = []; projectiles = []; logProjectiles = []; attackEffects = [];
             playerTowers = createTowers(true); enemyTowers = createTowers(false); gameTimeRemaining = BATTLE_DURATION_SECONDS;
             isTiebreakerActive = false; tiebreakerEffectCounter = 0; isTargetingSpell = false; currentSpellType = null; isPlacingBuilding = false; currentBuildingType = null;
             hideMessage(); stopGameTimers(); populateBattleControls(); updateDisplays(); updateBattleButtons();
             if (ctx) { console.log("Drawing initial state..."); ctx.clearRect(0, 0, canvas.width, canvas.height); playerTowers.forEach(drawTower); enemyTowers.forEach(drawTower); }
             else { console.error("Cannot draw initial state - context missing."); return; }
             console.log("Starting game intervals and loop...");
             elixirIntervalId = setInterval(updateElixir, ELIXIR_REGEN_INTERVAL);
             // --- *** MODIFIED: Use new AI function *** ---
             if (aiIntervalId) clearInterval(aiIntervalId); // Clear previous interval if any
             aiIntervalId = setInterval(updateAI, AI_DEPLOY_INTERVAL); // Call updateAI
             // --- End Modification ---
             startGameTimer();
             if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); console.log("Battle Started!");
        }

        // --- Screen Switching Logic ---
        function switchToDeckBuilder() { /* ... (no changes) ... */
            console.log("Switching to Deck Builder..."); stopGameTimers(); hideMessage(); if (deckBuilderScreen) deckBuilderScreen.classList.add('active'); if (battleScreen) battleScreen.classList.remove('active'); renderSelectedDeck();
        }
        function switchToBattle() { /* ... (no changes) ... */
            if (selectedDeck.length !== DECK_SIZE) { showMessage(`Please select exactly ${DECK_SIZE} cards!`); setTimeout(hideMessage, 2500); return; }
            console.log("Switching to Battle Screen..."); if (deckBuilderScreen) deckBuilderScreen.classList.remove('active'); if (battleScreen) battleScreen.classList.add('active'); initializeGame();
        }

        // --- Event Listeners Setup ---
        function setupDeployButtonListeners() { /* ... (no changes) ... */
            const buttons = battleControlsContainer ? battleControlsContainer.querySelectorAll('.deploy-button') : [];
            buttons.forEach(button => {
                 const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button);
                 const cardId = newButton.dataset.id; const cardType = newButton.dataset.type; const cardCost = parseInt(newButton.dataset.cost || '99'); const card = getCardById(cardId);
                 if (card && card.implemented) {
                     newButton.addEventListener('click', (event) => {
                         if (!gameOver && !isTiebreakerActive && !isTargetingSpell && !isPlacingBuilding && card.implemented && playerElixir >= cardCost) {
                             console.log(`Attempting Use: ${cardId}. Type: ${cardType}. Elixir=${playerElixir}, Cost=${cardCost}`); playerElixir -= cardCost; updateDisplays(); updateBattleButtons();
                             const rect = canvas.getBoundingClientRect(); const clickX = event ? event.clientX - rect.left : PLAYER_SIDE_X_LIMIT / 2; const clickY = event ? event.clientY - rect.top : canvas.height / 2;
                             handleDeployAction(cardId, clickX, clickY);
                         } else { console.log(`Cannot use ${cardId}. Conditions: Elixir=${playerElixir}, Cost=${cardCost}, Implemented=${card?.implemented}, GameOver=${gameOver}, Tiebreaker=${isTiebreakerActive}, Targeting=${isTargetingSpell}, Placing=${isPlacingBuilding}`); }
                     });
                 } else { newButton.disabled = true; }
            });
        }
        if (startBattleButton) startBattleButton.addEventListener('click', switchToBattle);
        if (resetButton) resetButton.addEventListener('click', switchToDeckBuilder);

        // --- Initial Setup on Load ---
        window.onload = () => { /* ... (no changes) ... */
             console.log("Window loaded. Setting up Deck Builder.");
             if (!deckBuilderScreen || !battleScreen || !cardLibraryContainer || !selectedDeckContainer || !canvas || !ctx || !startBattleButton || !resetButton || !gameTimerDisplay || !playerElixirDisplaySpan || !playerElixirBarFill || !placementIndicator) {
                 console.error("Essential DOM elements not found! Aborting setup."); document.body.innerHTML = '<h1 style="color:red; text-align: center;">Error loading game elements. Please refresh the page.</h1>'; return;
             } try { renderCardLibrary(); renderSelectedDeck(); deckBuilderScreen.classList.add('active'); battleScreen.classList.remove('active'); console.log("Deck Builder setup complete."); }
             catch (error) { console.error("Error during initial setup:", error); document.body.innerHTML = '<h1 style="color:red; text-align: center;">An error occurred during setup. Please refresh.</h1>'; }
        };

        // Override populateBattleControls to ensure listeners are re-attached
        const originalPopulateBattleControls = populateBattleControls;
        populateBattleControls = () => {
            originalPopulateBattleControls();
            setTimeout(setupDeployButtonListeners, 0);
        };

    </script>

</body>
</html>
